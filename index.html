<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Birthday Game</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #game {
        width: 100vw;
        height: 100vh;
        background: #000;
        cursor: crosshair;
        position: relative;
      }
      
      /* Among Us style vignette (dark edges) */
      #game::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background: radial-gradient(circle at center, transparent 0%, transparent 30%, rgba(0,0,0,0.4) 60%, rgba(0,0,0,0.8) 100%);
        z-index: 50;
      }

      canvas {
        display: block;
      }

      /* UI Overlay */
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-size: 18px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        pointer-events: none;
        z-index: 100;
      }

      #timer {
        font-size: 24px;
        font-weight: bold;
        color: #ff6666;
      }

      #status {
        margin-top: 10px;
        padding: 10px;
        background: rgba(0,0,0,0.6);
        border-radius: 5px;
      }

      #instructions {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        text-align: center;
        background: rgba(0,0,0,0.7);
        padding: 15px;
        border-radius: 10px;
        pointer-events: none;
      }

      #flashlight-battery {
        position: absolute;
        bottom: 20px;
        right: 20px;
        color: #ffdd00;
        font-size: 16px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
      }

      /* Menu System */
      #menu {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-family: Arial, sans-serif;
      }

      #menu.hidden {
        display: none;
      }

      #menu h1 {
        color: #fff;
        font-size: 48px;
        margin-bottom: 20px;
        text-shadow: 0 0 20px rgba(255,100,100,0.5);
      }

      #menu p {
        color: #aaa;
        font-size: 18px;
        margin-bottom: 40px;
      }

      .story {
        background: rgba(255,255,255,0.1);
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
        text-align: left;
        line-height: 1.6;
      }

      .story p {
        margin: 10px 0;
        font-size: 16px;
      }

      .story strong {
        color: #ffaa00;
      }

      .menu-buttons {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 30px;
      }

      .menu-btn {
        font-size: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(102,126,234,0.4);
      }

      .menu-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102,126,234,0.6);
      }

      .menu-btn.secondary {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }
      
      /* README Button */
      #readme-btn {
        position: absolute;
        top: 20px;
        left: 20px;
        padding: 12px 24px;
        font-size: 16px;
        font-weight: bold;
        background: linear-gradient(135deg, #4CAF50, #45a049);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        transition: transform 0.2s, box-shadow 0.2s;
        z-index: 1001;
      }
      
      #readme-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 12px rgba(0,0,0,0.5);
      }
      
      /* README Modal */
      #readme-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.9);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 2000;
      }
      
      #readme-modal.show {
        display: flex;
      }
      
      .readme-content {
        background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
        padding: 40px;
        border-radius: 15px;
        max-width: 800px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        color: white;
      }
      
      .readme-content h2 {
        color: #ffaa00;
        margin-top: 0;
        font-size: 32px;
        text-align: center;
        text-shadow: 0 0 10px rgba(255,170,0,0.5);
      }
      
      .readme-content h3 {
        color: #4CAF50;
        margin-top: 25px;
        font-size: 22px;
      }
      
      .readme-content p {
        line-height: 1.8;
        color: #ddd;
        margin: 10px 0;
      }
      
      .readme-content ul {
        line-height: 1.8;
        color: #ddd;
        margin: 10px 0;
        padding-left: 25px;
      }
      
      .readme-content li {
        margin: 8px 0;
      }
      
      .readme-content strong {
        color: #ffaa00;
      }
      
      .readme-content code {
        background: rgba(255,255,255,0.1);
        padding: 2px 6px;
        border-radius: 3px;
        color: #4CAF50;
      }
      
      #close-readme {
        display: block;
        margin: 30px auto 0;
        padding: 12px 40px;
        font-size: 18px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s;
      }
      
      #close-readme:hover {
        transform: scale(1.05);
      }

      #spotted-warning {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255,0,0,0.8);
        color: white;
        padding: 30px 60px;
        border-radius: 15px;
        font-size: 32px;
        font-weight: bold;
        display: none;
        z-index: 200;
        animation: pulse 0.5s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }

      #noise-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        border: 3px solid rgba(255,200,0,0.6);
        border-radius: 50%;
        display: none;
        z-index: 150;
        animation: ripple 1s ease-out;
      }

      @keyframes ripple {
        0% { width: 50px; height: 50px; opacity: 1; }
        100% { width: 200px; height: 200px; opacity: 0; }
      }

      /* E Key Hint */
      #e-hint {
        position: absolute;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,200,0,0.9);
        color: white;
        padding: 15px 30px;
        border-radius: 10px;
        font-size: 20px;
        font-weight: bold;
        display: none;
        z-index: 150;
        animation: bounce 0.5s ease-in-out infinite alternate;
      }

      /* Hiding Phase UI */
      #hiding-phase {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,100,0,0.8);
        padding: 20px 40px;
        border-radius: 15px;
        text-align: center;
        display: none;
        z-index: 100;
        pointer-events: none;
        border: 3px solid #00ff00;
      }
      
      #hiding-phase button {
        pointer-events: auto;
      }

      #hiding-phase h2 {
        color: #00ff00;
        font-size: 36px;
        margin-bottom: 20px;
      }

      #hiding-phase p {
        color: #ffffff;
        font-size: 20px;
        margin-bottom: 30px;
      }

      #hiding-phase #hide-timer {
        color: #ffff00;
        font-size: 48px;
        font-weight: bold;
        margin-bottom: 30px;
      }

      #hiding-phase button {
        padding: 15px 40px;
        font-size: 24px;
        background: linear-gradient(135deg, #00ff00 0%, #00aa00 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
      }

      #hiding-phase button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0,255,0,0.6);
      }

      /* Click to Start */
      #click-to-start {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.9);
        padding: 40px 60px;
        border-radius: 20px;
        text-align: center;
        z-index: 2000;
        border: 3px solid #00ff00;
        animation: pulse 1s ease-in-out infinite;
      }

      #click-to-start h2 {
        color: #00ff00;
        font-size: 48px;
        margin: 0 0 20px 0;
      }

      #click-to-start p {
        color: #ffffff;
        font-size: 24px;
        margin: 0;
      }

      @keyframes pulse {
        0%, 100% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(1.05); }
      }

      @keyframes bounce {
        0% { transform: translateX(-50%) translateY(0); }
        100% { transform: translateX(-50%) translateY(-10px); }
      }

      /* Game Over Screen */
      #game-over {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.95);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2000;
      }

      #game-over.show {
        display: flex;
      }

      #game-over h1 {
        font-size: 64px;
        margin-bottom: 20px;
        color: #ff3333;
        text-shadow: 0 0 20px rgba(255,51,51,0.8);
      }

      #game-over.win h1 {
        color: #33ff33;
        text-shadow: 0 0 20px rgba(51,255,51,0.8);
      }

      #game-over p {
        font-size: 24px;
        color: #ffffff;
        margin-bottom: 40px;
      }

      #game-over .buttons {
        display: flex;
        gap: 20px;
      }

      #game-over button {
        padding: 15px 40px;
        font-size: 20px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: bold;
      }

      #game-over .restart-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      #game-over .restart-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102,126,234,0.6);
      }

      #game-over .quit-btn {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
      }

      #game-over .quit-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(240,147,251,0.6);
      }
    </style>
  </head>
  <body>
    <!-- README Button (Top Left - hidden during game) -->
    <button id="readme-btn" onclick="showReadme()" style="display: block;">üìñ HOW TO PLAY</button>
    
    <!-- README Modal -->
    <div id="readme-modal">
      <div class="readme-content">
        <h2>üìñ HOW TO PLAY - BIRTHDAY CAKE HUNT</h2>
        
        <h3>üéØ OBJECTIVE</h3>
        <p>Collect all <strong>3 Birthday Candles</strong> and perform the <strong>Birthday Ritual</strong> at the altar to win!</p>
        
        <h3>üéÆ CONTROLS</h3>
        <ul>
          <li><code>W/A/S/D</code> - Move</li>
          <li><code>Mouse</code> - Look around</li>
          <li><code>Shift</code> - Sneak (slow, quiet)</li>
          <li><code>Ctrl + W</code> - Sprint (fast, loud!)</li>
          <li><code>E</code> - Hide in spots / Perform ritual</li>
          <li><code>C</code> - Use Camera Card (reveals cake)</li>
          <li><code>F</code> - Toggle flashlight</li>
        </ul>
        
        <h3>üîä VOLUME SYSTEM</h3>
        <p>Your <strong>volume builds up gradually</strong> as you move:</p>
        <ul>
          <li><strong>Sneaking:</strong> +0.3% per frame (slow buildup)</li>
          <li><strong>Walking:</strong> +0.8% per frame (medium buildup)</li>
          <li><strong>Sprinting:</strong> +2.0% per frame (fast buildup!)</li>
          <li><strong>Standing Still:</strong> -1.5% per frame (decreases)</li>
        </ul>
        <p><strong>Detection Threshold:</strong> When near the cake, the threshold drops from 100% to <strong>40% minimum</strong>. The closer the cake, the easier you're detected!</p>
        
        <h3>üïØÔ∏è COLLECTIBLES</h3>
        <ul>
          <li><strong>3 Candles:</strong> Random locations each game (small, white, glowing)</li>
          <li><strong>2 Camera Cards:</strong> Press [C] to reveal cake on map for 10 seconds</li>
          <li><strong>1 Birthday Shield:</strong> Protects from one cake attack</li>
        </ul>
        
        <h3>üéÇ THE CAKE</h3>
        <ul>
          <li>Patrols the <strong>entire house</strong> (27 waypoints)</li>
          <li>Detects you when your volume exceeds the threshold</li>
          <li>Catches teammates who don't hide fast enough</li>
          <li><strong>Caught teammates become cakes</strong> and hunt you!</li>
          <li>Use <strong>directional audio compass</strong> to track cake location</li>
        </ul>
        
        <h3>‚ú® WINNING THE GAME</h3>
        <ol>
          <li>Collect all 3 candles</li>
          <li>Navigate to the <strong>Altar</strong> (center of house - marked on minimap)</li>
          <li>Stand near altar and <strong>hold E for 5 seconds</strong></li>
          <li>Complete the ritual = <strong>YOU WIN!</strong></li>
        </ol>
        
        <h3>üó∫Ô∏è MINIMAP</h3>
        <ul>
          <li><strong>Green arrow:</strong> You (shows facing direction)</li>
          <li><strong>Yellow dots:</strong> Alive teammates</li>
          <li><strong>Pink dots:</strong> Teammates who became cakes</li>
          <li><strong>Red dot:</strong> Original cake (when visible)</li>
          <li><strong>Orange marker:</strong> Altar location</li>
          <li><strong>Grey lines:</strong> Walls and room dividers</li>
        </ul>
        
        <h3>üí° PRO TIPS</h3>
        <ul>
          <li>Use <strong>burst movement</strong>: Walk ‚Üí Stop ‚Üí Walk to manage volume</li>
          <li>Watch the <strong>threshold</strong> - it shows how close you can get to detection</li>
          <li>Save <strong>Camera Cards</strong> for critical moments (like the ritual)</li>
          <li>The <strong>shield is rare</strong> - use it wisely!</li>
          <li>Hide when volume gets too high - it resets to 0</li>
          <li>Sneaking near cake is safer but slower</li>
          <li>Check console (F12) for tool spawn locations</li>
        </ul>
        
        <h3>‚ö†Ô∏è DANGER ZONES</h3>
        <ul>
          <li><strong>Near Cake:</strong> Threshold drops to 40% - very dangerous!</li>
          <li><strong>Center (Altar):</strong> Exposed position for ritual</li>
          <li><strong>Multiple Cakes:</strong> Late game when teammates are caught</li>
        </ul>
        
        <button id="close-readme" onclick="closeReadme()">CLOSE</button>
      </div>
    </div>
    
    <!-- Main Menu -->
    <div id="menu">
      <h1>üéÇ THE BIRTHDAY CURSE</h1>
      <div class="story">
        <p style="font-style: italic; color: #ff6b6b; margin-bottom: 15px;">"It was supposed to be a celebration..."</p>
        <p>Your father's birthday party was going perfectly until <strong>midnight struck</strong>.</p>
        <p>The birthday cake‚Äîa beautiful pink creation with glowing candles‚Äîsuddenly <strong>came to life</strong>.</p>
        <p>Its frosting twisted into a sinister grin, its candles burned with unnatural flame, and its eyes... those terrible glowing eyes... locked onto you.</p>
        <p style="margin-top: 10px;">The cake's curse spread through the house, transforming your family into mindless cake servants.</p>
        <p style="margin-top: 10px; font-weight: bold; color: #ffd93d;">Now you're trapped in this nightmare mansion with 10 rooms of terror.</p>
        <p style="margin-top: 10px; color: #ff6b6b;">The cake hunts relentlessly, teleporting through shadows when it hears you, moving faster than any human should.</p>
        <p style="margin-top: 15px; font-size: 18px; font-weight: bold; color: #fff;">Can you survive your father's birthday party?</p>
      </div>
      <p style="margin-top: 20px; font-size: 18px;">Choose your game mode</p>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="showRoleSelection()">üéÆ PLAY GAME</button>
        <button class="menu-btn secondary" onclick="startOnline()">üåê Play Online</button>
        <button class="menu-btn" onclick="goToGameCentre()" style="background: linear-gradient(135deg, #667eea, #764ba2);">üéÆ GAME CENTRE</button>
      </div>
    </div>
    
    <!-- Role Selection Menu -->
    <div id="role-menu" class="hidden">
      <h1>üéÆ CHOOSE YOUR ROLE</h1>
      <div class="story">
        <p><strong>üïµÔ∏è HIDER:</strong> Hide from the evil birthday cake! Survive 5 minutes until midnight.</p>
        <p><strong>üéÇ CAKE HUNTER:</strong> You control the cake! Hunt down the party guest hiding in your house.</p>
        <p><strong>üåü EXPLORER:</strong> Freely explore the house with no danger. Perfect for learning the layout!</p>
      </div>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="startSoloAsHider()">üïµÔ∏è Play as HIDER</button>
        <button class="menu-btn" onclick="startSoloAsSeeker()">üéÇ Play as CAKE</button>
        <button class="menu-btn" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);" onclick="startCreativeMode()">üåü EXPLORE MODE</button>
        <button class="menu-btn secondary" onclick="backToMainMenu()">‚¨ÖÔ∏è Back</button>
      </div>
    </div>

    <!-- Game UI -->
    <div id="game"></div>
    <div id="ui" style="display: none;">
      <div id="timer">Time: 300s</div>
      <div id="status">
        <div style="font-weight: bold; color: #ffd93d; margin-bottom: 8px;">üéÇ THE BIRTHDAY CURSE</div>
        <div>Role: <span id="role">Hider</span></div>
        <div>üïØÔ∏è Candles: <span id="candles">0/3</span></div>
        <div style="margin-top: 8px; font-size: 14px; color: #aaa;">
          <div>üìö Spell Book: Teleport [V]</div>
          <div>üì∑ Camera Card: See Cake [C]</div>
          <div>üîá Stay Quiet: Loud = Cake Teleports!</div>
        </div>
      </div>
    </div>
    <div id="flashlight-battery" style="display: none;">üî¶ Battery: 100%</div>
    <div id="volume-meter" style="position: absolute; top: 260px; left: 20px; color: white; font-size: 18px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); display: none; pointer-events: none; z-index: 100; background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.2);">
      <div style="font-weight: bold; margin-bottom: 5px; text-align: center;">üîä YOUR VOLUME</div>
      <div id="volume-bar" style="width: 180px; height: 18px; background: #222; border: 2px solid #555; border-radius: 4px; overflow: hidden;">
        <div id="volume-fill" style="height: 100%; width: 0%; background: linear-gradient(to right, #0f0, #ff0, #f00); transition: width 0.1s;"></div>
      </div>
      <div id="volume-text" style="font-size: 13px; margin-top: 5px; text-align: center;">Sneaking: 0%</div>
    </div>
    <div id="instructions" style="display: none;">
      WASD: Move | Mouse: Look | Shift: Sneak | F: Flashlight | E: Hide | C: Camera Card | V: Spell Book | ESC: Pause
    </div>
    <div id="tools-ui" style="position: absolute; bottom: 20px; right: 20px; color: white; font-size: 16px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); display: none; pointer-events: none; z-index: 100; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px;">
      <div id="camera-card-ui" style="display: none; margin-bottom: 5px;">üì∑ Camera Card: Press [C]</div>
      <div id="shield-ui" style="display: none;">üõ°Ô∏è Shield: Active</div>
    </div>
    <!-- New Cake Audio Line System -->
    <div id="cake-audio" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); width: 80%; max-width: 800px; display: none; pointer-events: none; z-index: 100;">
      <!-- Horizontal line with directional indicators -->
      <div style="position: relative; width: 100%; height: 60px; background: rgba(0,0,0,0.5); border-radius: 8px; padding: 10px;">
        <!-- Center line -->
        <div style="position: absolute; top: 50%; left: 0; right: 0; height: 3px; background: #444; transform: translateY(-50%);"></div>
        
        <!-- Center marker (you) -->
        <div style="position: absolute; top: 50%; left: 50%; width: 4px; height: 20px; background: #0f0; transform: translate(-50%, -50%);"></div>
        
        <!-- Original Cake (Red) -->
        <div id="original-cake-indicator" style="position: absolute; top: 50%; display: none;">
          <div style="width: 3px; height: 30px; background: #ff0000; transform: translateY(-50%);"></div>
          <div style="position: absolute; top: -25px; left: 50%; transform: translateX(-50%); font-size: 11px; color: #ff0000; white-space: nowrap; text-shadow: 1px 1px 2px black;">
            <div id="original-cake-percent" style="font-weight: bold;">0%</div>
          </div>
        </div>
        
        <!-- Teammate 1 Cake (Pink) -->
        <div id="teammate1-cake-indicator" style="position: absolute; top: 50%; display: none;">
          <div style="width: 3px; height: 30px; background: #ff69b4; transform: translateY(-50%);"></div>
          <div style="position: absolute; top: -25px; left: 50%; transform: translateX(-50%); font-size: 11px; color: #ff69b4; white-space: nowrap; text-shadow: 1px 1px 2px black;">
            <div id="teammate1-cake-percent" style="font-weight: bold;">0%</div>
          </div>
        </div>
        
        <!-- Teammate 2 Cake (White) -->
        <div id="teammate2-cake-indicator" style="position: absolute; top: 50%; display: none;">
          <div style="width: 3px; height: 30px; background: #ffffff; transform: translateY(-50%);"></div>
          <div style="position: absolute; top: -25px; left: 50%; transform: translateX(-50%); font-size: 11px; color: #ffffff; white-space: nowrap; text-shadow: 1px 1px 2px black;">
            <div id="teammate2-cake-percent" style="font-weight: bold;">0%</div>
          </div>
        </div>
        
        <!-- Label at bottom -->
        <div style="position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); font-size: 12px; color: #aaa; text-shadow: 1px 1px 2px black;">
          Cake Footsteps
        </div>
      </div>
    </div>
    <div id="click-to-start" style="display: none;">
      <h2>üñ±Ô∏è CLICK TO START</h2>
      <p>Click anywhere to lock mouse and begin playing</p>
      <p style="font-size: 14px; margin-top: 10px;">Press ESC to unlock mouse</p>
    </div>
    <div id="spotted-warning">‚ö†Ô∏è SPOTTED! ‚ö†Ô∏è</div>
    <div id="noise-indicator"></div>
    <div id="e-hint">Press [E] to Hide</div>
    <div id="r-hint" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff0; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px #000; display: none; pointer-events: none; z-index: 200;">Press [R] to Catch!</div>
    
    <!-- Mini-map (top right, shows teammates) -->
    <div id="minimap" style="position: absolute; top: 80px; right: 10px; width: 200px; height: 200px; background: rgba(0,0,0,0.8); border: 2px solid #4a4; border-radius: 5px; display: none; z-index: 100;">
      <canvas id="minimap-canvas" width="200" height="200"></canvas>
      <div style="position: absolute; top: 2px; left: 5px; color: #4a4; font-size: 10px; font-weight: bold;">MAP</div>
    </div>
    
    <!-- Hiding Phase Screen -->
    <div id="hiding-phase">
      <h2>üïµÔ∏è HIDING PHASE</h2>
      <p>Find a hiding spot before the seeker starts!</p>
      <div id="hide-timer">120</div>
      <button onclick="startSeekerPhase()" style="margin-top: 20px; padding: 15px 40px; font-size: 20px; font-weight: bold; background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none; border-radius: 10px; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.4); transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 12px rgba(0,0,0,0.5)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.4)';">
        ‚úÖ I'M READY!
      </button>
      <p style="font-size: 14px; margin-top: 10px; opacity: 0.7;">Click when you're ready to start the game</p>
    </div>
    
    <!-- Pause Menu -->
    <div id="pause-menu" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 1000;">
      <div style="text-align: center; max-width: 400px;">
        <h1 style="color: white; font-size: 48px; margin-bottom: 20px;">‚è∏Ô∏è PAUSED</h1>
        <p style="color: #aaa; margin-bottom: 30px; font-size: 16px;">Press ESC to resume or choose an option:</p>
        <div class="menu-buttons">
          <button class="menu-btn" onclick="resumeGame()" style="padding: 15px 40px;">‚ñ∂Ô∏è Resume Game</button>
          <button class="menu-btn secondary" onclick="quitGame()" style="padding: 15px 40px;">üè† Main Menu</button>
          <button class="menu-btn" onclick="goToGameCentre()" style="padding: 15px 40px; background: linear-gradient(135deg, #667eea, #764ba2);">üéÆ Game Centre</button>
        </div>
      </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over">
      <h1 id="game-over-title">GAME OVER</h1>
      <p id="game-over-message">You were caught!</p>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="restartGame()">üîÑ Play Again</button>
        <button class="menu-btn secondary" onclick="quitGame()">üè† Main Menu</button>
        <button class="menu-btn" onclick="goToGameCentre()" style="background: linear-gradient(135deg, #667eea, #764ba2);">üéÆ Game Centre</button>
      </div>
    </div>
    
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    
    <script>
      // README Modal functions
      window.showReadme = function() {
        document.getElementById('readme-modal').classList.add('show');
      };
      
      window.closeReadme = function() {
        document.getElementById('readme-modal').classList.remove('show');
      };
      
      // Menu functions (must be outside module to work with onclick)
      window.showRoleSelection = function() {
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('role-menu').classList.remove('hidden');
        
        // Hide README button when picking role
        document.getElementById('readme-btn').style.display = 'none';
      };
      
      window.backToMainMenu = function() {
        document.getElementById('role-menu').classList.add('hidden');
        document.getElementById('menu').classList.remove('hidden');
        
        // Show README button again when back to main menu
        document.getElementById('readme-btn').style.display = 'block';
      };
      
      window.startSoloAsHider = function() {
        console.log('Hider button clicked!');
        window.gameMode = 'solo';
        window.playerRole = 'hider';
        console.log('Set gameMode:', window.gameMode, 'playerRole:', window.playerRole);
        
        // Hide README button when game starts
        document.getElementById('readme-btn').style.display = 'none';
        
        // Wait for module to load with multiple retries
        let retries = 0;
        const maxRetries = 20; // Try for 2 seconds
        
        function tryStart() {
          if (window.startGameNow) {
            console.log('Calling startGameNow...');
            window.startGameNow();
          } else {
            retries++;
            if (retries < maxRetries) {
              console.log('startGameNow not ready, retry', retries, '/', maxRetries);
              setTimeout(tryStart, 100);
            } else {
              alert('Game failed to load! Check console for errors and refresh the page.');
            }
          }
        }
        
        tryStart();
      };
      
      window.startSoloAsSeeker = function() {
        window.gameMode = 'solo';
        window.playerRole = 'seeker';
        if (window.startGameNow) {
          window.startGameNow();
        } else {
          setTimeout(() => window.startGameNow(), 100);
        }
      };
      
      window.startCreativeMode = function() {
        window.gameMode = 'creative';
        window.playerRole = 'explorer';
        if (window.startGameNow) {
          window.startGameNow();
        } else {
          setTimeout(() => window.startGameNow(), 100);
        }
      };
      
      window.startOnline = function() {
        alert('Online multiplayer requires server setup. Run: npm install && npm start');
      };
      
      window.restartGame = function() {
        location.reload();
      };
      
      window.quitGame = function() {
        location.reload();
      };
      
      window.goToGameCentre = function() {
        window.location.href = '../game centre /index.html';
      };
      
      window.resumeGame = function() {
        document.getElementById('pause-menu').style.display = 'none';
        // Re-lock pointer
        if (document.pointerLockElement === null) {
          document.body.requestPointerLock();
        }
      };
      
      window.startSeekerPhase = function() {
        window.hidingPhaseActive = false;
        document.getElementById('hiding-phase').style.display = 'none';
      };
    </script>
    
    <script type="module">
      console.log('Module script starting...');
      
      import * as THREE from 'three';
      console.log('THREE imported:', typeof THREE);
      
      import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
      console.log('PointerLockControls imported:', typeof PointerLockControls);

      // IMMEDIATELY create startGameNow so buttons work
      let gameMode = null;
      let gameStarted = false;
      let startGameFunction = null;
      
      window.startGameNow = function() {
        console.log('startGameNow called! gameMode:', window.gameMode, 'playerRole:', window.playerRole);
        gameMode = window.gameMode;
        if (startGameFunction) {
          try {
            startGameFunction();
          } catch(e) {
            console.error('Error starting game:', e);
            alert('Error starting game: ' + e.message);
          }
        } else {
          alert('Game is still loading, please wait...');
        }
      };
      
      console.log('startGameNow created immediately!');

      // Wrap everything in try-catch to find errors
      try {

      // Scene setup
      console.log('Creating scene...');
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a1a); // Very dark background
      scene.fog = new THREE.Fog(0x0a0a1a, 5, 20); // Heavy fog, short distance (Among Us style)

      // Camera (first-person)
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1.6, 40); // Start near south wall (safe spawn, away from wall)

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('game').appendChild(renderer.domElement);

      // DARK LIGHTING - Limited visibility like Among Us
      const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3); // Very dark ambient
      scene.add(ambientLight);

      // Dim directional light
      const dirLight = new THREE.DirectionalLight(0x4a4a6a, 0.4);
      dirLight.position.set(5, 10, 5);
      dirLight.castShadow = true;
      dirLight.shadow.camera.near = 0.1;
      dirLight.shadow.camera.far = 100;
      scene.add(dirLight);

      // Dim atmospheric point light
      const pointLight = new THREE.PointLight(0x4a4a6a, 0.5, 30);
      pointLight.position.set(0, 3, 0);
      pointLight.castShadow = true;
      scene.add(pointLight);

      // === REALISTIC SINGLE-FLOOR HOUSE STRUCTURE ===
      const houseWidth = 120; // MUCH BIGGER single floor!
      const houseDepth = 100; // MUCH BIGGER single floor!
      const floorHeight = 4;
      const wallThickness = 0.3;
      const doorWidth = 2.5;
      const doorHeight = 3;
      const windowSize = 2;

      // Realistic house materials
      const floorMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x8b7355, // Wood floor
        roughness: 0.7,
        metalness: 0.1
      });
      const wallMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xd4c5b0, // Beige walls
        roughness: 0.8
      });
      const ceilingMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xf5f5f5, // White ceiling
        roughness: 0.9
      });
      const doorMaterial = new THREE.MeshStandardMaterial({
        color: 0x654321, // Brown door
        roughness: 0.6
      });
      const windowMaterial = new THREE.MeshStandardMaterial({
        color: 0x87ceeb, // Light blue glass
        transparent: true,
        opacity: 0.3,
        roughness: 0.1,
        metalness: 0.5
      });
      const stairMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b7355, // Wood stairs
        roughness: 0.7
      });
      
      // === FLOORS ===
      // Ground floor (1st floor)
      const floor1 = new THREE.Mesh(
        new THREE.PlaneGeometry(houseWidth, houseDepth),
        floorMaterial
      );
      floor1.rotation.x = -Math.PI / 2;
      floor1.receiveShadow = true;
      scene.add(floor1);
      
      // Ceiling (single floor only)
      const ceiling = new THREE.Mesh(
        new THREE.PlaneGeometry(houseWidth, houseDepth),
        ceilingMaterial
      );
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.y = floorHeight;
      ceiling.receiveShadow = true;
      scene.add(ceiling);

      // === COLLISION OBSTACLES AND HIDING SPOTS ===
      const obstacles = [];
      const lockers = []; // Hiding spots
      
      // Outer walls (added to obstacles for collision)
      const outerWallHeight = floorHeight;
      
      // North wall
      const northWall = new THREE.Mesh(
        new THREE.BoxGeometry(houseWidth, outerWallHeight, wallThickness),
        wallMaterial
      );
      northWall.position.set(0, outerWallHeight / 2, -houseDepth / 2);
      northWall.receiveShadow = true;
      northWall.castShadow = true;
      scene.add(northWall);
      obstacles.push(northWall);

      // South wall
      const southWall = new THREE.Mesh(
        new THREE.BoxGeometry(houseWidth, outerWallHeight, wallThickness),
        wallMaterial
      );
      southWall.position.set(0, outerWallHeight / 2, houseDepth / 2);
      southWall.receiveShadow = true;
      southWall.castShadow = true;
      scene.add(southWall);
      obstacles.push(southWall);

      // West wall
      const westWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, outerWallHeight, houseDepth),
        wallMaterial
      );
      westWall.position.set(-houseWidth / 2, outerWallHeight / 2, 0);
      westWall.receiveShadow = true;
      westWall.castShadow = true;
      scene.add(westWall);
      obstacles.push(westWall);

      // East wall
      const eastWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, outerWallHeight, houseDepth),
        wallMaterial
      );
      eastWall.position.set(houseWidth / 2, outerWallHeight / 2, 0);
      eastWall.receiveShadow = true;
      eastWall.castShadow = true;
      scene.add(eastWall);
      obstacles.push(eastWall);

      // === REALISTIC INTERIOR STRUCTURE ===
      // (obstacles and lockers already declared above)
      
      // Helper function to create wall with door opening
      function createWallWithDoor(x, y, z, width, height, depth, doorPos, isVertical = false) {
        const doorOffset = doorPos || 0;
        
        if (isVertical) {
          // Wall before door
          if (doorOffset > doorWidth / 2) {
            const wall1 = new THREE.Mesh(
              new THREE.BoxGeometry(depth, height, doorOffset - doorWidth / 2),
              wallMaterial
            );
            wall1.position.set(x, y, z - (width / 2) + (doorOffset - doorWidth / 2) / 2);
            wall1.receiveShadow = true;
            wall1.castShadow = true;
            scene.add(wall1);
            obstacles.push(wall1);
          }
          
          // Wall after door
          if (doorOffset < width - doorWidth / 2) {
            const wall2 = new THREE.Mesh(
              new THREE.BoxGeometry(depth, height, width - doorOffset - doorWidth / 2),
              wallMaterial
            );
            wall2.position.set(x, y, z + (width / 2) - (width - doorOffset - doorWidth / 2) / 2);
            wall2.receiveShadow = true;
            wall2.castShadow = true;
            scene.add(wall2);
            obstacles.push(wall2);
          }
          
          // Door frame
          const door = new THREE.Mesh(
            new THREE.BoxGeometry(depth * 2, doorHeight, doorWidth),
            doorMaterial
          );
          door.position.set(x, y - (height - doorHeight) / 2, z - width / 2 + doorOffset);
          door.receiveShadow = true;
          door.castShadow = true;
          scene.add(door);
        } else {
          // Horizontal wall with door
          // Wall before door
          if (doorOffset > doorWidth / 2) {
            const wall1 = new THREE.Mesh(
              new THREE.BoxGeometry(doorOffset - doorWidth / 2, height, depth),
              wallMaterial
            );
            wall1.position.set(x - (width / 2) + (doorOffset - doorWidth / 2) / 2, y, z);
            wall1.receiveShadow = true;
            wall1.castShadow = true;
            scene.add(wall1);
            obstacles.push(wall1);
          }
          
          // Wall after door
          if (doorOffset < width - doorWidth / 2) {
            const wall2 = new THREE.Mesh(
              new THREE.BoxGeometry(width - doorOffset - doorWidth / 2, height, depth),
              wallMaterial
            );
            wall2.position.set(x + (width / 2) - (width - doorOffset - doorWidth / 2) / 2, y, z);
            wall2.receiveShadow = true;
            wall2.castShadow = true;
            scene.add(wall2);
            obstacles.push(wall2);
          }
          
          // Door frame
          const door = new THREE.Mesh(
            new THREE.BoxGeometry(doorWidth, doorHeight, depth * 2),
            doorMaterial
          );
          door.position.set(x - width / 2 + doorOffset, y - (height - doorHeight) / 2, z);
          door.receiveShadow = true;
          door.castShadow = true;
          scene.add(door);
        }
      }
      
      // Function to create window
      function createWindow(x, y, z, isVertical = false) {
        const windowFrame = new THREE.Mesh(
          isVertical ? 
            new THREE.BoxGeometry(0.2, windowSize, windowSize) :
            new THREE.BoxGeometry(windowSize, windowSize, 0.2),
          windowMaterial
        );
        windowFrame.position.set(x, y, z);
        windowFrame.receiveShadow = true;
        windowFrame.castShadow = true;
        scene.add(windowFrame);
      }
      
      // === FIRST FLOOR LAYOUT - 10 ROOMS (SINGLE FLOOR) ===
      // Complex maze-like layout with multiple hallways
      
      // Main vertical dividers (creates 3 columns)
      createWallWithDoor(-25, floorHeight / 2, 0, houseDepth, floorHeight, wallThickness, houseDepth / 2, true); // Left column
      createWallWithDoor(25, floorHeight / 2, 0, houseDepth, floorHeight, wallThickness, houseDepth / 2, true);  // Right column
      
      // Left column rooms (3 rooms) - Rooms 1, 2, 3
      createWallWithDoor(-35, floorHeight / 2, -13, 20, floorHeight, wallThickness, 10, false); // Room 1-2 divider
      createWallWithDoor(-35, floorHeight / 2, 13, 20, floorHeight, wallThickness, 10, false);  // Room 2-3 divider
      
      // Center column rooms (4 rooms) - Rooms 4, 5, 6, 7
      createWallWithDoor(0, floorHeight / 2, -20, 50, floorHeight, wallThickness, 25, false); // Room 4-5 divider (top)
      createWallWithDoor(0, floorHeight / 2, 0, 50, floorHeight, wallThickness, 25, false);   // Room 5-6 divider (middle)
      createWallWithDoor(0, floorHeight / 2, 20, 50, floorHeight, wallThickness, 25, false);  // Room 6-7 divider (bottom)
      
      // Right column rooms (3 rooms) - Rooms 8, 9, 10
      createWallWithDoor(35, floorHeight / 2, -13, 20, floorHeight, wallThickness, 10, false); // Room 8-9 divider
      createWallWithDoor(35, floorHeight / 2, 13, 20, floorHeight, wallThickness, 10, false);  // Room 9-10 divider
      
      // === NO STAIRS - SINGLE FLOOR ===
      
      // === WINDOWS (MORE IN BIGGER HOUSE) ===
      // First floor windows
      createWindow(-houseWidth / 2 + 0.1, floorHeight / 2, -20, true);
      createWindow(-houseWidth / 2 + 0.1, floorHeight / 2, 0, true);
      createWindow(-houseWidth / 2 + 0.1, floorHeight / 2, 20, true);
      createWindow(houseWidth / 2 - 0.1, floorHeight / 2, -20, true);
      createWindow(houseWidth / 2 - 0.1, floorHeight / 2, 0, true);
      createWindow(houseWidth / 2 - 0.1, floorHeight / 2, 20, true);
      
      // Second floor windows
      createWindow(-houseWidth / 2 + 0.1, floorHeight + floorHeight / 2, -20, true);
      createWindow(-houseWidth / 2 + 0.1, floorHeight + floorHeight / 2, 0, true);
      createWindow(-houseWidth / 2 + 0.1, floorHeight + floorHeight / 2, 20, true);
      createWindow(houseWidth / 2 - 0.1, floorHeight + floorHeight / 2, -20, true);
      createWindow(houseWidth / 2 - 0.1, floorHeight + floorHeight / 2, 0, true);
      createWindow(houseWidth / 2 - 0.1, floorHeight + floorHeight / 2, 20, true);
      
      // === REALISTIC ROOM LIGHTING - 10 ROOMS (SINGLE FLOOR) ===
      const roomLights = [
        // Left column (3 rooms)
        {x: -35, z: -20, floor: 1}, // Room 1 (left-top)
        {x: -35, z: 0, floor: 1},   // Room 2 (left-middle)
        {x: -35, z: 20, floor: 1},  // Room 3 (left-bottom)
        
        // Center column (4 rooms)
        {x: 0, z: -27, floor: 1},   // Room 4 (center-top)
        {x: 0, z: -10, floor: 1},   // Room 5 (center-upper-mid)
        {x: 0, z: 10, floor: 1},    // Room 6 (center-lower-mid)
        {x: 0, z: 27, floor: 1},    // Room 7 (center-bottom)
        
        // Right column (3 rooms)
        {x: 35, z: -20, floor: 1},  // Room 8 (right-top)
        {x: 35, z: 0, floor: 1},    // Room 9 (right-middle)
        {x: 35, z: 20, floor: 1}    // Room 10 (right-bottom)
      ];
      
      roomLights.forEach(light => {
        const y = light.floor === 1 ? floorHeight - 0.3 : floorHeight * 2 - 0.3;
        
        // Light fixture (visible bulb)
        const bulb = new THREE.Mesh(
          new THREE.SphereGeometry(0.15, 8, 8),
          new THREE.MeshStandardMaterial({ 
            color: 0xffffaa,
            emissive: 0xffffaa,
            emissiveIntensity: 1
          })
        );
        bulb.position.set(light.x, y, light.z);
        scene.add(bulb);
        
        // Point light - MUCH BRIGHTER
        const roomLight = new THREE.PointLight(0xffffee, 2.5, 25);
        roomLight.position.set(light.x, y, light.z);
        roomLight.castShadow = true;
        scene.add(roomLight);
      });

      // === HIDING SPOTS (Multiple Types) ===
      const hidingSpots = []; // All hiding spots
      
      // Materials for hiding spots
      const normalMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x4a3a2a,
        roughness: 0.7,
        metalness: 0.4
      });
      
      // Glowing material for hiders (only visible to hiders)
      const hiderMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x2a4a2a,
        roughness: 0.7,
        metalness: 0.3,
        emissive: 0x1a3a1a,
        emissiveIntensity: 0.5
      });
      
      // === 1. LOCKERS ===
      const lockerGeometry = new THREE.BoxGeometry(1.5, 2.5, 1);
      
      // === REALISTIC LOCKER POSITIONS (SINGLE FLOOR - MORE SPREAD OUT) ===
      const lockerPositions = [
        {x: -50, y: 1.25, z: -40},
        {x: -30, y: 1.25, z: -40},
        {x: -50, y: 1.25, z: 40},
        {x: -30, y: 1.25, z: 40},
        {x: 50, y: 1.25, z: -40},
        {x: 30, y: 1.25, z: -40},
        {x: 50, y: 1.25, z: 40},
        {x: 30, y: 1.25, z: 40},
        {x: -50, y: 1.25, z: 0},
        {x: 50, y: 1.25, z: 0},
        {x: 0, y: 1.25, z: -40},
        {x: 0, y: 1.25, z: 40}
      ];
      
      lockerPositions.forEach(pos => {
        const locker = new THREE.Mesh(lockerGeometry, normalMaterial.clone());
        locker.position.set(pos.x, pos.y, pos.z);
        locker.castShadow = true;
        locker.receiveShadow = true;
        locker.userData.isHidingSpot = true;
        locker.userData.type = 'locker';
        locker.userData.occupied = false;
        scene.add(locker);
        lockers.push(locker);
        hidingSpots.push(locker);
        obstacles.push(locker);
      });
      
      // === 2. BEDS (In bedrooms only) ===
      const bedPositions = [
        {x: -38, y: 0.3, z: -20},  // Bedroom 1 (left-top)
        {x: 38, y: 0.3, z: -20}    // Bedroom 2 (right-top)
      ];
      
      bedPositions.forEach(pos => {
        // Bed frame
        const bedFrame = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 0.6, 2),
          new THREE.MeshStandardMaterial({ color: 0x5a4a3a, roughness: 0.8 })
        );
        bedFrame.position.set(pos.x, pos.y, pos.z);
        bedFrame.castShadow = true;
        bedFrame.receiveShadow = true;
        scene.add(bedFrame);
        
        // Hiding spot under bed (invisible marker)
        const underBed = new THREE.Mesh(
          new THREE.BoxGeometry(2, 0.5, 1.8),
          normalMaterial.clone()
        );
        underBed.position.set(pos.x, pos.y - 0.2, pos.z);
        underBed.visible = false; // Invisible to both
        underBed.userData.isHidingSpot = true;
        underBed.userData.type = 'bed';
        underBed.userData.occupied = false;
        scene.add(underBed);
        hidingSpots.push(underBed);
      });
      
      // === 3. CURTAINS (Behind curtains) ===
      const curtainPositions = [
        {x: -55, y: 2, z: -20, rotation: Math.PI / 2},
        {x: 55, y: 2, z: -20, rotation: -Math.PI / 2},
        {x: -55, y: 2, z: 20, rotation: Math.PI / 2},
        {x: 55, y: 2, z: 20, rotation: -Math.PI / 2},
        {x: -55, y: 2, z: 0, rotation: Math.PI / 2},
        {x: 55, y: 2, z: 0, rotation: -Math.PI / 2}
      ];
      
      curtainPositions.forEach(pos => {
        // Curtain visual
        const curtain = new THREE.Mesh(
          new THREE.PlaneGeometry(2, 3),
          new THREE.MeshStandardMaterial({ 
            color: 0x6a3a3a, 
            roughness: 0.9,
            side: THREE.DoubleSide
          })
        );
        curtain.position.set(pos.x, pos.y, pos.z);
        curtain.rotation.y = pos.rotation;
        curtain.castShadow = true;
        curtain.receiveShadow = true;
        scene.add(curtain);
        
        // Hiding spot behind curtain
        const behindCurtain = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 2.5, 0.5),
          normalMaterial.clone()
        );
        behindCurtain.position.set(pos.x, pos.y, pos.z);
        behindCurtain.visible = false;
        behindCurtain.userData.isHidingSpot = true;
        behindCurtain.userData.type = 'curtain';
        behindCurtain.userData.occupied = false;
        scene.add(behindCurtain);
        hidingSpots.push(behindCurtain);
      });
      
      // === 4. CLOSETS (Large wardrobes) ===
      const closetPositions = [
        // First floor
        {x: -15, y: 1.5, z: -18},
        {x: 15, y: 1.5, z: -18},
        {x: -15, y: 1.5, z: 18},
        {x: 15, y: 1.5, z: 18},
        // Second floor
        {x: -15, y: floorHeight + 1.5, z: -18},
        {x: 15, y: floorHeight + 1.5, z: -18},
        {x: -15, y: floorHeight + 1.5, z: 18},
        {x: 15, y: floorHeight + 1.5, z: 18}
      ];
      
      closetPositions.forEach(pos => {
        // Closet visual (larger than locker)
        const closet = new THREE.Mesh(
          new THREE.BoxGeometry(2, 3, 1.2),
          new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.8 })
        );
        closet.position.set(pos.x, pos.y, pos.z);
        closet.castShadow = true;
        closet.receiveShadow = true;
        closet.userData.isHidingSpot = true;
        closet.userData.type = 'closet';
        closet.userData.occupied = false;
        scene.add(closet);
        hidingSpots.push(closet);
        obstacles.push(closet);
      });
      
      // === 5. CLOSETS (Small closets) - 2 MORE ADDED ===
      const atticPositions = [
        {x: -45, y: 1.5, z: -25},
        {x: 45, y: 1.5, z: -25},
        {x: -45, y: 1.5, z: 25},
        {x: 45, y: 1.5, z: 25},
        {x: 0, y: 1.5, z: -45},  // NEW
        {x: 0, y: 1.5, z: 45}    // NEW
      ];
      
      atticPositions.forEach(pos => {
        // Attic hatch visual
        const hatch = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 0.2, 1.5),
          new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.9 })
        );
        hatch.position.set(pos.x, pos.y, pos.z);
        hatch.castShadow = true;
        hatch.receiveShadow = true;
        scene.add(hatch);
        
        // Hiding spot in attic
        const attic = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 0.8, 1.5),
          normalMaterial.clone()
        );
        attic.position.set(pos.x, pos.y, pos.z);
        attic.visible = false;
        attic.userData.isHidingSpot = true;
        attic.userData.type = 'attic';
        attic.userData.occupied = false;
        scene.add(attic);
        hidingSpots.push(attic);
      });
      
      // === 6. BATHROOM STALLS ===
      const bathroomPositions = [
        // First floor
        {x: -12, y: 1.2, z: -16},
        {x: 12, y: 1.2, z: -16},
        // Second floor
        {x: -12, y: floorHeight + 1.2, z: -16},
        {x: 12, y: floorHeight + 1.2, z: -16}
      ];
      
      bathroomPositions.forEach(pos => {
        // Bathroom stall walls
        const stall = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 2.4, 1.5),
          new THREE.MeshStandardMaterial({ color: 0x5a5a5a, roughness: 0.7 })
        );
        stall.position.set(pos.x, pos.y, pos.z);
        stall.castShadow = true;
        stall.receiveShadow = true;
        stall.userData.isHidingSpot = true;
        stall.userData.type = 'bathroom';
        stall.userData.occupied = false;
        scene.add(stall);
        hidingSpots.push(stall);
        obstacles.push(stall);
      });
      
      // === BIRTHDAY CANDLES (Collectibles!) ===
      const candles = []; // Declare array first!
      const tools = []; // Declare tools array too!
      
      // === BIRTHDAY CAKE ALTAR (Win Condition) ===
      const altarGroup = new THREE.Group();
      
      // Altar platform
      const altarPlatform = new THREE.Mesh(
        new THREE.CylinderGeometry(2, 2.5, 0.5, 8),
        new THREE.MeshStandardMaterial({ 
          color: 0x8b4513,
          roughness: 0.8
        })
      );
      altarPlatform.position.y = 0.25;
      altarPlatform.castShadow = true;
      altarGroup.add(altarPlatform);
      
      // Altar top (stone)
      const altarTop = new THREE.Mesh(
        new THREE.CylinderGeometry(1.8, 1.8, 0.3, 8),
        new THREE.MeshStandardMaterial({ 
          color: 0x696969,
          roughness: 0.6,
          metalness: 0.2
        })
      );
      altarTop.position.y = 0.65;
      altarTop.castShadow = true;
      altarGroup.add(altarTop);
      
      // Glowing ring
      const altarGlow = new THREE.Mesh(
        new THREE.RingGeometry(1.5, 1.7, 32),
        new THREE.MeshStandardMaterial({ 
          color: 0xffaa00,
          emissive: 0xff6600,
          emissiveIntensity: 0.8,
          side: THREE.DoubleSide
        })
      );
      altarGlow.rotation.x = -Math.PI / 2;
      altarGlow.position.y = 0.81;
      altarGroup.add(altarGlow);
      
      // Position altar in HALL (Room 7)
      altarGroup.position.set(0, 0, 27);
      altarGroup.userData.isAltar = true;
      scene.add(altarGroup);
      console.log('üéÇ Birthday Altar created in HALL (0, 0, 27)');
      
      function createCandle(x, z) {
        const group = new THREE.Group();
        
        // Candle body (white cylinder) - SMALLER
        const candleBody = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.15, 1, 8),
          new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        candleBody.position.y = 0.5;
        candleBody.castShadow = true;
        group.add(candleBody);
        
        // Flame (yellow/orange sphere) - SMALLER
        const flame = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 8, 8),
          new THREE.MeshStandardMaterial({ 
            color: 0xffaa00,
            emissive: 0xff6600,
            emissiveIntensity: 1
          })
        );
        flame.position.y = 1.2;
        group.add(flame);
        
        // Glow light
        const candleLight = new THREE.PointLight(0xffaa00, 0.5, 3);
        candleLight.position.y = 1.2;
        group.add(candleLight);
        
        // Pulsing animation
        group.userData.pulseTime = Math.random() * Math.PI * 2;
        
        group.position.set(x, 0, z);
        group.userData.isCandle = true;
        group.userData.collected = false;
        
        return group;
      }
      
      // Random candle positions (different each game!)
      function generateRandomCandlePositions() {
        const positions = [];
        const rooms = [
          { x: -35, z: -25, name: 'Northwest' },
          { x: -35, z: 25, name: 'Southwest' },
          { x: 35, z: -25, name: 'Northeast' },
          { x: 35, z: 25, name: 'Southeast' },
          { x: 0, z: -30, name: 'North Center' },
          { x: 0, z: 30, name: 'South Center' },
          { x: -30, z: 0, name: 'West Center' },
          { x: 30, z: 0, name: 'East Center' },
          { x: 0, z: 0, name: 'Center' }
        ];
        
        // Shuffle and pick 3 random positions
        const shuffled = rooms.sort(() => Math.random() - 0.5);
        for (let i = 0; i < 3; i++) {
          const room = shuffled[i];
          // Add some randomness within the room
          positions.push({
            x: room.x + (Math.random() - 0.5) * 10,
            z: room.z + (Math.random() - 0.5) * 10
          });
        }
        return positions;
      }
      
      const candlePositions = generateRandomCandlePositions();
      console.log('üïØÔ∏è Candles spawned at random positions!');
      
      candlePositions.forEach(pos => {
        const candle = createCandle(pos.x, pos.z);
        candles.push(candle);
        scene.add(candle);
      });
      
      // === TOOLS (Collectible Power-ups!) ===
      function createTool(x, z, type) {
        const group = new THREE.Group();
        
        if (type === 'camera') {
          // Camera Card - Blue card with camera icon
          const card = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1.5, 0.1),
            new THREE.MeshStandardMaterial({ color: 0x2196F3, emissive: 0x1976D2, emissiveIntensity: 0.5 })
          );
          card.position.y = 1;
          card.rotation.y = Math.PI / 4;
          group.add(card);
          
          // Camera lens (circle)
          const lens = new THREE.Mesh(
            new THREE.CircleGeometry(0.3, 16),
            new THREE.MeshStandardMaterial({ color: 0x000000 })
          );
          lens.position.set(0, 1, 0.06);
          group.add(lens);
          
          group.userData.toolType = 'camera';
          group.userData.toolName = 'üì∑ Camera Card';
        } else if (type === 'shield') {
          // Birthday Shield - Golden shield
          const shield = new THREE.Mesh(
            new THREE.CircleGeometry(0.8, 6),
            new THREE.MeshStandardMaterial({ 
              color: 0xFFD700, 
              emissive: 0xFFA500, 
              emissiveIntensity: 0.5,
              metalness: 0.8
            })
          );
          shield.position.y = 1;
          shield.rotation.y = Math.PI / 4;
          group.add(shield);
          
          // Star in center
          const star = new THREE.Mesh(
            new THREE.CircleGeometry(0.3, 5),
            new THREE.MeshStandardMaterial({ color: 0xFFFFFF, emissive: 0xFFFFFF, emissiveIntensity: 1 })
          );
          star.position.set(0, 1, 0.05);
          group.add(star);
          
          group.userData.toolType = 'shield';
          group.userData.toolName = 'üõ°Ô∏è Birthday Shield';
        }
        
        group.position.set(x, 0, z);
        group.userData.isTool = true;
        group.userData.collected = false;
        group.userData.rotationSpeed = 0.02;
        
        return group;
      }
      
      // Spawn 3 tools randomly: 2 Camera Cards + 1 Shield (away from player spawn)
      function generateRandomToolPositions() {
        const playerSpawn = new THREE.Vector3(0, 0, 40); // Player spawns here
        const possibleLocations = [
          { x: -35, z: -25, name: 'Northwest' },
          { x: -35, z: 25, name: 'Southwest' },
          { x: 35, z: -25, name: 'Northeast' },
          { x: 35, z: 25, name: 'Southeast' },
          { x: 0, z: -30, name: 'North Center' },
          { x: -30, z: 0, name: 'West Center' },
          { x: 30, z: 0, name: 'East Center' }
        ];
        
        // Filter out locations too close to player spawn (< 30 units)
        const validLocations = possibleLocations.filter(loc => {
          const dist = Math.sqrt((loc.x - playerSpawn.x) ** 2 + (loc.z - playerSpawn.z) ** 2);
          return dist > 30;
        });
        
        // Shuffle valid locations
        const shuffled = validLocations.sort(() => Math.random() - 0.5);
        
        return [
          { x: shuffled[0].x, z: shuffled[0].z, type: 'camera', location: shuffled[0].name },
          { x: shuffled[1].x, z: shuffled[1].z, type: 'camera', location: shuffled[1].name },
          { x: shuffled[2].x, z: shuffled[2].z, type: 'shield', location: shuffled[2].name }
        ];
      }
      
      const toolPositions = generateRandomToolPositions();
      console.log('üîß Tools spawned:');
      toolPositions.forEach(tool => {
        console.log(`  ${tool.type === 'camera' ? 'üì∑' : 'üõ°Ô∏è'} ${tool.type} at ${tool.location} (${tool.x}, ${tool.z})`);
      });
      
      toolPositions.forEach(pos => {
        const tool = createTool(pos.x, pos.z, pos.type);
        tools.push(tool);
        scene.add(tool);
      });
      console.log('üîß Tools spawned: Camera Card & Birthday Shield');
      
      // === REALISTIC ROOM OBJECTS (Can make noise!) ===
      const roomObjects = [];
      
      // Tables with items
      const tablePositions = [
        // First floor
        {x: -25, y: 0.4, z: -18, floor: 1},
        {x: -25, y: 0.4, z: 18, floor: 1},
        {x: 25, y: 0.4, z: -18, floor: 1},
        {x: 25, y: 0.4, z: 18, floor: 1},
        // Second floor
        {x: -25, y: floorHeight + 0.4, z: -18, floor: 2},
        {x: -25, y: floorHeight + 0.4, z: 18, floor: 2},
        {x: 25, y: floorHeight + 0.4, z: -18, floor: 2},
        {x: 25, y: floorHeight + 0.4, z: 18, floor: 2}
      ];
      
      tablePositions.forEach(pos => {
        // Table
        const table = new THREE.Mesh(
          new THREE.BoxGeometry(2, 0.8, 1.5),
          new THREE.MeshStandardMaterial({ color: 0x5a4a3a, roughness: 0.7 })
        );
        table.position.set(pos.x, pos.y, pos.z);
        table.castShadow = true;
        table.receiveShadow = true;
        table.userData.canMakeNoise = true;
        table.userData.noiseName = 'table';
        scene.add(table);
        obstacles.push(table);
        roomObjects.push(table);
        
        // Cup on table (can knock over)
        const cup = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.08, 0.2, 8),
          new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.5 })
        );
        cup.position.set(pos.x + 0.5, pos.y + 0.5, pos.z);
        cup.castShadow = true;
        cup.userData.canMakeNoise = true;
        cup.userData.noiseName = 'cup';
        scene.add(cup);
        roomObjects.push(cup);
      });
      
      // === FURNITURE FOR 10 ROOMS ===
      // Chairs (2 per room = 20 chairs)
      const chairPositions = [
        // Left wing (Rooms 1-3)
        {x: -38, y: 0.3, z: -22}, {x: -32, y: 0.3, z: -18}, // Room 1
        {x: -38, y: 0.3, z: -2}, {x: -32, y: 0.3, z: 2},    // Room 2
        {x: -38, y: 0.3, z: 18}, {x: -32, y: 0.3, z: 22},   // Room 3
        
        // Center section (Rooms 4-7)
        {x: -5, y: 0.3, z: -28}, {x: 5, y: 0.3, z: -24},    // Room 4
        {x: -5, y: 0.3, z: -12}, {x: 5, y: 0.3, z: -8},     // Room 5
        {x: -5, y: 0.3, z: 8}, {x: 5, y: 0.3, z: 12},       // Room 6
        {x: -5, y: 0.3, z: 24}, {x: 5, y: 0.3, z: 28},      // Room 7
        
        // Right wing (Rooms 8-10)
        {x: 32, y: 0.3, z: -22}, {x: 38, y: 0.3, z: -18},   // Room 8
        {x: 32, y: 0.3, z: -2}, {x: 38, y: 0.3, z: 2},      // Room 9
        {x: 32, y: 0.3, z: 18}, {x: 38, y: 0.3, z: 22}      // Room 10
      ];
      
      chairPositions.forEach(pos => {
        const chair = new THREE.Mesh(
          new THREE.BoxGeometry(0.8, 0.6, 0.8),
          new THREE.MeshStandardMaterial({ color: 0x4a3a2a, roughness: 0.8 })
        );
        chair.position.set(pos.x, pos.y, pos.z);
        chair.castShadow = true;
        chair.receiveShadow = true;
        chair.userData.canMakeNoise = true;
        chair.userData.noiseName = 'chair';
        scene.add(chair);
        obstacles.push(chair);
        roomObjects.push(chair);
      });
      
      // Bookshelves (1 per room = 10 shelves)
      const shelfPositions = [
        // Left wing
        {x: -42, y: 1, z: -20}, // Room 1
        {x: -42, y: 1, z: 0},   // Room 2
        {x: -42, y: 1, z: 20},  // Room 3
        
        // Center section
        {x: -10, y: 1, z: -26}, // Room 4
        {x: -10, y: 1, z: -10}, // Room 5
        {x: -10, y: 1, z: 10},  // Room 6
        {x: -10, y: 1, z: 26},  // Room 7
        
        // Right wing
        {x: 42, y: 1, z: -20},  // Room 8
        {x: 42, y: 1, z: 0},    // Room 9
        {x: 42, y: 1, z: 20}    // Room 10
      ];
      
      shelfPositions.forEach(pos => {
        const shelf = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 2, 0.5),
          new THREE.MeshStandardMaterial({ color: 0x3a2a1a, roughness: 0.8 })
        );
        shelf.position.set(pos.x, pos.y, pos.z);
        shelf.castShadow = true;
        shelf.receiveShadow = true;
        shelf.userData.canMakeNoise = true;
        shelf.userData.noiseName = 'bookshelf';
        scene.add(shelf);
        obstacles.push(shelf);
        roomObjects.push(shelf);
      });
      
      // Vases, Plants, Boxes, Lamps (30+ decorative items for 10 rooms)
      const decorativePositions = [
        // Left wing decorations
        {x: -36, y: 0.3, z: -24, type: 'vase'},   // Room 1
        {x: -40, y: 0.5, z: -18, type: 'plant'},  // Room 1
        {x: -36, y: 0.3, z: -4, type: 'vase'},    // Room 2
        {x: -40, y: 0.5, z: 2, type: 'box'},      // Room 2
        {x: -36, y: 0.3, z: 16, type: 'vase'},    // Room 3
        {x: -40, y: 0.5, z: 22, type: 'plant'},   // Room 3
        
        // Center section decorations
        {x: -8, y: 0.3, z: -30, type: 'vase'},    // Room 4
        {x: 8, y: 0.5, z: -26, type: 'box'},      // Room 4
        {x: -8, y: 0.3, z: -14, type: 'plant'},   // Room 5
        {x: 8, y: 0.5, z: -10, type: 'vase'},     // Room 5
        {x: -8, y: 0.3, z: 6, type: 'vase'},      // Room 6
        {x: 8, y: 0.5, z: 10, type: 'plant'},     // Room 6
        {x: -8, y: 0.3, z: 22, type: 'box'},      // Room 7
        {x: 8, y: 0.5, z: 26, type: 'vase'},      // Room 7
        
        // Right wing decorations
        {x: 36, y: 0.3, z: -24, type: 'plant'},   // Room 8
        {x: 40, y: 0.5, z: -18, type: 'vase'},    // Room 8
        {x: 36, y: 0.3, z: -4, type: 'box'},      // Room 9
        {x: 40, y: 0.5, z: 2, type: 'plant'},     // Room 9
        {x: 36, y: 0.3, z: 16, type: 'vase'},     // Room 10
        {x: 40, y: 0.5, z: 22, type: 'box'},      // Room 10
        
        // Additional hallway decorations
        {x: -18, y: 0.5, z: -30, type: 'box'},
        {x: 18, y: 0.5, z: -30, type: 'box'},
        {x: -18, y: 0.5, z: 30, type: 'plant'},
        {x: 18, y: 0.5, z: 30, type: 'plant'},
        {x: 0, y: 0.3, z: -22, type: 'vase'},
        {x: 0, y: 0.3, z: 22, type: 'vase'},
        {x: -40, y: 0.5, z: 25, type: 'plant'},
        {x: 40, y: 0.5, z: 25, type: 'plant'},
        // Barrels
        {x: -20, y: 0.4, z: -30, type: 'barrel'},
        {x: 20, y: 0.4, z: -30, type: 'barrel'},
        {x: -20, y: 0.4, z: 30, type: 'barrel'},
        {x: 20, y: 0.4, z: 30, type: 'barrel'},
        // Lamps
        {x: -35, y: 1, z: 0, type: 'lamp'},
        {x: 35, y: 1, z: 0, type: 'lamp'},
        {x: 0, y: 1, z: -30, type: 'lamp'},
        {x: 0, y: 1, z: 30, type: 'lamp'}
      ];
      
      decorativePositions.forEach(pos => {
        let item;
        if (pos.type === 'vase') {
          item = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.2, 0.6, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.4 })
          );
        } else if (pos.type === 'box') {
          item = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshStandardMaterial({ color: 0x8b6914, roughness: 0.9 })
          );
        } else if (pos.type === 'plant') {
          item = new THREE.Mesh(
            new THREE.ConeGeometry(0.3, 0.8, 8),
            new THREE.MeshStandardMaterial({ color: 0x2a5a2a, roughness: 0.8 })
          );
        } else if (pos.type === 'barrel') {
          item = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.4, 0.8, 12),
            new THREE.MeshStandardMaterial({ color: 0x6a4a2a, roughness: 0.9 })
          );
        } else if (pos.type === 'lamp') {
          item = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.3, 1, 8),
            new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 0.3 })
          );
        }
        item.position.set(pos.x, pos.y, pos.z);
        item.castShadow = true;
        item.receiveShadow = true;
        item.userData.canMakeNoise = true;
        item.userData.noiseName = pos.type;
        scene.add(item);
        obstacles.push(item);
        roomObjects.push(item);
      });
      
      // === THEMED ROOM FURNITURE ===
      
      // BATHROOM (Room 2 - left middle) - Toilet & Sink
      const toilet = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.8, 0.8),
        new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 })
      );
      toilet.position.set(-40, 0.4, -2);
      toilet.castShadow = true;
      toilet.receiveShadow = true;
      scene.add(toilet);
      obstacles.push(toilet);
      
      const sink = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.5, 0.6),
        new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.3, metalness: 0.5 })
      );
      sink.position.set(-40, 0.8, 2);
      sink.castShadow = true;
      sink.receiveShadow = true;
      scene.add(sink);
      obstacles.push(sink);
      
      // KITCHEN (Room 6 - center lower-mid) - Counter & Stove
      const counter = new THREE.Mesh(
        new THREE.BoxGeometry(3, 0.9, 0.8),
        new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 0.6 })
      );
      counter.position.set(-8, 0.45, 12);
      counter.castShadow = true;
      counter.receiveShadow = true;
      scene.add(counter);
      obstacles.push(counter);
      
      const stove = new THREE.Mesh(
        new THREE.BoxGeometry(1, 0.9, 0.8),
        new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4, metalness: 0.6 })
      );
      stove.position.set(8, 0.45, 12);
      stove.castShadow = true;
      stove.receiveShadow = true;
      scene.add(stove);
      obstacles.push(stove);
      
      // STUDY (Room 3 - left bottom) - Desk
      const desk = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.8, 1.2),
        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.7 })
      );
      desk.position.set(-38, 0.4, 20);
      desk.castShadow = true;
      desk.receiveShadow = true;
      scene.add(desk);
      obstacles.push(desk);
      
      // OFFICE (Room 9 - right middle) - Desk & Filing Cabinet
      const officeDesk = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.8, 1.2),
        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.7 })
      );
      officeDesk.position.set(38, 0.4, 0);
      officeDesk.castShadow = true;
      officeDesk.receiveShadow = true;
      scene.add(officeDesk);
      obstacles.push(officeDesk);
      
      const filingCabinet = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 1.2, 0.6),
        new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5, metalness: 0.7 })
      );
      filingCabinet.position.set(40, 0.6, -3);
      filingCabinet.castShadow = true;
      filingCabinet.receiveShadow = true;
      scene.add(filingCabinet);
      obstacles.push(filingCabinet);
      
      // DINING ROOM (Room 5 - center upper-mid) - Dining Table
      const diningTable = new THREE.Mesh(
        new THREE.BoxGeometry(3, 0.8, 2),
        new THREE.MeshStandardMaterial({ color: 0x5a4a3a, roughness: 0.6 })
      );
      diningTable.position.set(0, 0.4, -10);
      diningTable.castShadow = true;
      diningTable.receiveShadow = true;
      scene.add(diningTable);
      obstacles.push(diningTable);
      
      // LIVING ROOM (Room 4 - center top) - Couch
      const couch = new THREE.Mesh(
        new THREE.BoxGeometry(2.5, 0.8, 1),
        new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.8 })
      );
      couch.position.set(0, 0.4, -27);
      couch.castShadow = true;
      couch.receiveShadow = true;
      scene.add(couch);
      obstacles.push(couch);

      // === FLASHLIGHT SYSTEM (Brighter in dark) ===
      const flashlight = new THREE.SpotLight(0xffffee, 8, 40, Math.PI / 3, 0.5, 1);
      flashlight.position.set(0, 0, 0);
      flashlight.castShadow = true;
      flashlight.shadow.mapSize.width = 1024;
      flashlight.shadow.mapSize.height = 1024;
      camera.add(flashlight);
      camera.add(flashlight.target);
      
      // Player vision light (always on - Among Us style)
      const visionLight = new THREE.PointLight(0xffffff, 2.5, 15, 2); // Limited range
      visionLight.position.set(0, 0, 0);
      camera.add(visionLight);
      flashlight.target.position.set(0, 0, -1);
      
      let flashlightOn = false;
      let flashlightBattery = 100;
      flashlight.visible = false;
      
      // E key hint
      let nearHidingSpot = null;
      
      // === AI SEEKER (EVIL BIRTHDAY CAKE!) ===
      // Create a birthday cake instead of capsule
      const cakeGroup = new THREE.Group();
      
      // Cake base (bottom layer)
      const cakeBase = new THREE.Mesh(
        new THREE.CylinderGeometry(0.6, 0.7, 0.5, 16),
        new THREE.MeshStandardMaterial({ 
          color: 0xffb6c1, // Pink frosting
          roughness: 0.3
        })
      );
      cakeBase.position.y = 0.25;
      cakeGroup.add(cakeBase);
      
      // Cake middle layer
      const cakeMiddle = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.6, 0.4, 16),
        new THREE.MeshStandardMaterial({ 
          color: 0xffd700, // Golden yellow
          roughness: 0.3
        })
      );
      cakeMiddle.position.y = 0.7;
      cakeGroup.add(cakeMiddle);
      
      // Cake top layer
      const cakeTop = new THREE.Mesh(
        new THREE.CylinderGeometry(0.4, 0.5, 0.3, 16),
        new THREE.MeshStandardMaterial({ 
          color: 0xff69b4, // Hot pink
          roughness: 0.3
        })
      );
      cakeTop.position.y = 1.05;
      cakeGroup.add(cakeTop);
      
      // Candle
      const candle = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8),
        new THREE.MeshStandardMaterial({ 
          color: 0xffff00, // Yellow candle
          emissive: 0xffff00,
          emissiveIntensity: 0.5
        })
      );
      candle.position.y = 1.35;
      cakeGroup.add(candle);
      
      // Flame
      const flame = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 8, 8),
        new THREE.MeshStandardMaterial({ 
          color: 0xff4500, // Orange flame
          emissive: 0xff4500,
          emissiveIntensity: 1.5
        })
      );
      flame.position.y = 1.55;
      cakeGroup.add(flame);
      
      // Evil eyes
      const leftEye = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 8, 8),
        new THREE.MeshStandardMaterial({ 
          color: 0xff0000, // Red evil eyes
          emissive: 0xff0000,
          emissiveIntensity: 1
        })
      );
      leftEye.position.set(-0.15, 0.9, 0.4);
      cakeGroup.add(leftEye);
      
      const rightEye = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 8, 8),
        new THREE.MeshStandardMaterial({ 
          color: 0xff0000,
          emissive: 0xff0000,
          emissiveIntensity: 1
        })
      );
      rightEye.position.set(0.15, 0.9, 0.4);
      cakeGroup.add(rightEye);
      
      const seeker = cakeGroup;
      seeker.position.set(-40, 0.8, -40); // Start in corner (away from player)
      seeker.castShadow = true;
      scene.add(seeker);
      
      // Cake's evil glow (dimmer in dark environment)
      const seekerFlashlight = new THREE.SpotLight(0xff69b4, 2.0, 25, Math.PI / 5, 0.5, 1);
      seekerFlashlight.position.copy(seeker.position);
      seekerFlashlight.position.y += 0.5;
      seekerFlashlight.castShadow = true;
      scene.add(seekerFlashlight);
      
      // Cake's vision light (Among Us style)
      const seekerVisionLight = new THREE.PointLight(0xff69b4, 1.5, 12, 2);
      seekerVisionLight.position.copy(seeker.position);
      scene.add(seekerVisionLight);
      const seekerTarget = new THREE.Object3D();
      scene.add(seekerTarget);
      seekerFlashlight.target = seekerTarget;
      
      // === AI TEAMMATES (Yellow Block Characters) ===
      function createYellowBlockCharacter(x, z, name) {
        const group = new THREE.Group();
        
        // Body (yellow block)
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, 1, 0.6),
          new THREE.MeshStandardMaterial({ 
            color: 0xffff00,
            roughness: 0.6
          })
        );
        body.position.y = 0.5;
        body.castShadow = true;
        group.add(body);
        
        // Head (smaller yellow block on top)
        const head = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.4, 0.4),
          new THREE.MeshStandardMaterial({ 
            color: 0xffff00,
            roughness: 0.6
          })
        );
        head.position.y = 1.2;
        head.castShadow = true;
        group.add(head);
        
        // Eyes
        const leftEye = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 0.08, 0.05),
          new THREE.MeshStandardMaterial({ color: 0x000000 })
        );
        leftEye.position.set(-0.1, 1.25, 0.21);
        group.add(leftEye);
        
        const rightEye = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 0.08, 0.05),
          new THREE.MeshStandardMaterial({ color: 0x000000 })
        );
        rightEye.position.set(0.1, 1.25, 0.21);
        group.add(rightEye);
        
        group.position.set(x, 0, z);
        group.userData.name = name;
        group.userData.isTeammate = true;
        group.userData.isHiding = false;
        group.userData.targetSpot = null;
        
        return group;
      }
      
      // Create 2 AI teammates (spawn near player at start)
      const teammates = [];
      const teammate1 = createYellowBlockCharacter(5, 38, 'Teammate 1'); // Near player spawn
      const teammate2 = createYellowBlockCharacter(-5, 38, 'Teammate 2'); // Near player spawn
      teammates.push(teammate1, teammate2);
      scene.add(teammate1);
      scene.add(teammate2);
      
      // AI Hider (only in seeker/cake mode - player hunts this)
      const aiHider = createYellowBlockCharacter(20, -35, 'AI Hider');
      aiHider.userData.isAIHider = true;
      scene.add(aiHider);
      
      // Seeker AI state (BALANCED SPEED)
      let seekerState = 'patrol'; // patrol, chase, search, checking
      let seekerSpeed = 0.045; // Faster patrol speed
      let seekerWaypoint = 0;
      let checkingSpot = null;
      let checkingTime = 0;
      let seekerDetectionRange = 35; // Longer vision than player
      let seekerChaseSpeed = 0.06; // Faster than player running (0.05)!
      
      // Audio proximity system (like Dark Zone Breakout)
      let cakeFootstepSound = null;
      let cakeFootstepVolume = 0;
      
      // Background music and sound effects (don't affect gameplay!)
      let backgroundMusic = null;
      let jumpscareSound = null;
      let lastJumpscareTime = 0;
      let lastAmbientJumpscareTime = 0;
      let nextAmbientJumpscareDelay = 0;
      
      // Spotted chase mode - like Granny game
      let spottedChaseTimer = 0;
      let cakeRushMode = false; // 2x speed when rushing to spotted location
      // Waypoints within the house
      const seekerWaypoints = [
        // Outer perimeter (covers whole house)
        new THREE.Vector3(-50, 0, -40),  // Northwest corner
        new THREE.Vector3(-30, 0, -40),  // North-west
        new THREE.Vector3(-10, 0, -40),  // North-west mid
        new THREE.Vector3(10, 0, -40),   // North-east mid
        new THREE.Vector3(30, 0, -40),   // North-east
        new THREE.Vector3(50, 0, -40),   // Northeast corner
        new THREE.Vector3(50, 0, -20),   // East upper
        new THREE.Vector3(50, 0, 0),     // East center
        new THREE.Vector3(50, 0, 20),    // East lower
        new THREE.Vector3(50, 0, 40),    // Southeast corner
        new THREE.Vector3(30, 0, 40),    // South-east
        new THREE.Vector3(10, 0, 40),    // South-east mid
        new THREE.Vector3(-10, 0, 40),   // South-west mid
        new THREE.Vector3(-30, 0, 40),   // South-west
        new THREE.Vector3(-50, 0, 40),   // Southwest corner
        new THREE.Vector3(-50, 0, 20),   // West lower
        new THREE.Vector3(-50, 0, 0),    // West center
        new THREE.Vector3(-50, 0, -20),  // West upper
        // Interior paths
        new THREE.Vector3(-30, 0, -20),  // Interior NW
        new THREE.Vector3(0, 0, -20),    // Interior N
        new THREE.Vector3(30, 0, -20),   // Interior NE
        new THREE.Vector3(30, 0, 0),     // Interior E
        new THREE.Vector3(30, 0, 20),    // Interior SE
        new THREE.Vector3(0, 0, 20),     // Interior S
        new THREE.Vector3(-30, 0, 20),   // Interior SW
        new THREE.Vector3(-30, 0, 0),    // Interior W
        new THREE.Vector3(0, 0, 0)       // Center (altar)
      ];
      
      // No visible body parts for player
      scene.add(camera);
      
      // === AUDIO ===
      const listener = new THREE.AudioListener();
      camera.add(listener);
      
      let isWalking = false;
      let walkingSoundTime = 0;
      
      // === GAME STATE ===
      let gameTime = 999999; // No time limit!
      let hideTime = 0; // No hiding phase
      let hidingPhase = false; // Start game immediately!
      let isHiding = false;
      let playersFound = 0;
      let totalPlayers = 3;
      let currentLocker = null;
      
      // Birthday Candles System
      let candlesFound = 0;
      const totalCandles = 3;
      let performingRitual = false;
      let ritualProgress = 0;
      const RITUAL_TIME = 5; // 5 seconds to complete ritual
      // candles array already declared above
      
      // Tools System
      let cameraCardCount = 0; // Can have multiple camera cards
      let cameraCardActive = false;
      let cameraCardTimer = 0;
      let hasSpellBook = false; // Spell book for teleportation
      // tools array already declared above
      
      // Volume and noise mechanics (GRADUAL BUILDUP SYSTEM)
      let volumeLevel = 0; // 0-100, increases gradually with movement
      let isSpotted = false;
      let spottedTimer = 0;
      let cakeAlreadyTeleported = false; // Prevent multiple teleports during same chase
      let detectionThreshold = 100; // Decreases when near cake (min 30)
      const SPOTTED_DURATION = 3; // 3 seconds to be caught after spotted
      let noiseTimer = 0;
      let lastNoiseTime = 0;
      let playerNoisePosition = null;
      let searchingTime = 0; // Time spent searching at noise location
      let hideTimer = 0; // Track how long in hiding spot
      const MAX_HIDE_TIME = 30; // 30 seconds max in one spot
      
      // Seeker visibility on minimap (persistent when near player or teammates)
      let seekerVisibleOnMap = false;
      
      // Timed seeker reveal (every 10 seconds for 3 seconds)
      let lastSeekerReveal = 0;
      let seekerTimedReveal = false;
      
      // Will set startGameFunction at the end after startGame is defined
      
      // No hiding phase - game starts immediately
      // (Function kept for compatibility but not used)
      window.startSeekerPhase = function() {
        console.log('Game already started - no hiding phase!');
      };
      
      function showGameOver(title, message, isWin = false) {
        const gameOverEl = document.getElementById('game-over');
        const titleEl = document.getElementById('game-over-title');
        const messageEl = document.getElementById('game-over-message');
        
        titleEl.textContent = title;
        messageEl.textContent = message;
        
        if (isWin) {
          gameOverEl.classList.add('win');
        } else {
          gameOverEl.classList.remove('win');
        }
        
        gameOverEl.classList.add('show');
        
        // Release pointer lock
        if (document.pointerLockElement) {
          document.exitPointerLock();
        }
      }
      
      function startGame() {
        const playerRole = window.playerRole;
        
        // COMPLETELY hide menus
        document.getElementById('menu').style.display = 'none';
        document.getElementById('role-menu').style.display = 'none';
        
        // Show game UI
        document.getElementById('ui').style.display = 'block';
        document.getElementById('flashlight-battery').style.display = 'block';
        document.getElementById('volume-meter').style.display = 'block';
        document.getElementById('instructions').style.display = 'block';
        document.getElementById('click-to-start').style.display = 'block';
        document.getElementById('tools-ui').style.display = 'block';
        document.getElementById('cake-audio').style.display = 'block';
        gameStarted = true;
        
        // Background music removed for better gameplay
        
        // Debug: Check spawn position
        console.log('Player spawn position:', camera.position);
        console.log('Collision at spawn?', checkCollision(camera.position));
        console.log('Game started! Role:', playerRole);
        console.log('hideTime:', hideTime, 'hidingPhase:', hidingPhase);
        
        if (playerRole === 'hider') {
          // Hider mode: Start immediately (no hiding phase)
          document.getElementById('hiding-phase').style.display = 'none';
          hidingPhase = false;
          
          // Show all hiding spots as green for hiders
          hidingSpots.forEach(spot => {
            spot.visible = true; // Make sure visible for hiders
            spot.material = hiderMaterial.clone();
          });
          
          // Show teammates, hide AI hider
          teammates.forEach(t => t.visible = true);
          aiHider.visible = false;
          
          // Show minimap
          document.getElementById('minimap').style.display = 'block';
          
          // DARK lighting for hider mode
          ambientLight.intensity = 0.3;
          dirLight.intensity = 0.4;
          pointLight.intensity = 0.5;
          scene.fog.near = 5;
          scene.fog.far = 20;
        } else if (playerRole === 'seeker') {
          // Seeker mode: No hiding phase, start immediately
          hidingPhase = false;
          document.getElementById('hiding-phase').style.display = 'none';
          
          // Seeker starts at different position (player is the cake)
          camera.position.set(40, 1.6, 40); // Opposite corner from AI spawn
          
          // Hide the AI seeker (player is the seeker now)
          seeker.visible = false;
          seekerFlashlight.visible = false;
          
          // HIDE all hiding spot markers for seeker!
          hidingSpots.forEach(spot => {
            spot.visible = false;
          });
          
          // Hide teammates, show AI hider (player hunts it)
          teammates.forEach(t => t.visible = false);
          aiHider.visible = true;
          
          // No minimap in seeker mode
          document.getElementById('minimap').style.display = 'none';
          
          // DARK lighting for seeker mode
          ambientLight.intensity = 0.3;
          dirLight.intensity = 0.4;
          pointLight.intensity = 0.5;
          scene.fog.near = 5;
          scene.fog.far = 20;
        } else if (playerRole === 'explorer') {
          // Creative/Explorer mode: No seeker, no hiding phase, no timer
          hidingPhase = false;
          document.getElementById('hiding-phase').style.display = 'none';
          
          // Show seeker immediately (no hiding phase)
          seeker.visible = true;
          seekerFlashlight.visible = true;
          console.log('Seeker active from start!');
          
          // Show all hiding spots as green for exploration
          hidingSpots.forEach(spot => {
            spot.visible = true; // Make sure visible
            spot.material = hiderMaterial.clone();
          });
          
          // Start at entrance (explorer mode)
          camera.position.set(0, 1.6, 45); // Near south wall
          
          // Unlimited flashlight battery
          flashlightBattery = 100;
          
          // Show all characters in explorer mode
          teammates.forEach(t => t.visible = true);
          aiHider.visible = true;
          
          // Show minimap
          document.getElementById('minimap').style.display = 'block';
          
          // BRIGHT LIGHTING for creative mode
          ambientLight.intensity = 1.5;
          dirLight.intensity = 1.5;
          pointLight.intensity = 2.0;
          scene.fog.near = 50;
          scene.fog.far = 120;
        }
        
        // Don't auto-lock, wait for user click
        // User will see "Click to Start" and click to begin
      }

      // First-person controls
      const controls = new PointerLockControls(camera, renderer.domElement);
      
      // Click to enable controls (anywhere on screen)
      document.addEventListener('click', () => {
        console.log('Click detected. gameStarted:', gameStarted, 'click-to-start visible:', document.getElementById('click-to-start').style.display);
        if (gameStarted) {
          document.getElementById('click-to-start').style.display = 'none';
          controls.lock();
          console.log('Controls locked! You can now move with WASD and look around.');
        }
      });
      
      // Debug: Check if controls lock/unlock
      controls.addEventListener('lock', () => {
        console.log('‚úÖ Pointer locked - movement enabled');
      });
      
      controls.addEventListener('unlock', () => {
        console.log('‚ùå Pointer unlocked - movement disabled');
      });
      
      // Hide click-to-start when pointer is locked
      controls.addEventListener('lock', () => {
        document.getElementById('click-to-start').style.display = 'none';
      });
      
      // Show click-to-start when pointer is unlocked (ESC pressed)
      controls.addEventListener('unlock', () => {
        if (gameStarted) {
          document.getElementById('click-to-start').style.display = 'block';
        }
      });

      // Movement and collision
      const sneakSpeed = 0.04;  // Sneaking speed (Shift) - increased from 0.025
      const walkSpeed = 0.08;   // Walking speed - increased from 0.05
      const sprintSpeed = 0.15; // Running speed - increased from 0.12
      let currentSpeed = walkSpeed;
      const keys = {};
      const playerRadius = 0.5;
      const collisionDistance = 2.5;
      
      // Camera shake variables
      let walkCycle = 0;
      const originalCameraY = camera.position.y;
      const sneakCameraY = originalCameraY - 0.4; // Lower camera when sneaking
      
      window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        
        // Pause with ESC
        if (e.key === 'Escape' && gameStarted) {
          const pauseMenu = document.getElementById('pause-menu');
          const clickToStart = document.getElementById('click-to-start');
          if (pauseMenu.style.display === 'flex') {
            // Resume
            pauseMenu.style.display = 'none';
          } else {
            // Pause
            pauseMenu.style.display = 'flex';
            // Hide the click-to-start overlay when showing pause menu
            if (clickToStart) clickToStart.style.display = 'none';
          }
          return;
        }
        
        // Sprint with Ctrl
        if (e.key === 'Control') {
          keys['ctrl'] = true;
        }
        // Sneak with Shift
        if (e.key === 'Shift') {
          keys['shift'] = true;
        }
        // Toggle flashlight with F
        if (e.key.toLowerCase() === 'f') {
          if (flashlightBattery > 0) {
            flashlightOn = !flashlightOn;
            flashlight.visible = flashlightOn;
          }
        }
        
        // Catch AI hider with R key (seeker mode)
        if (e.key.toLowerCase() === 'r' && gameStarted && window.playerRole === 'seeker') {
          const distance = camera.position.distanceTo(aiHider.position);
          if (distance < 3 && aiHider.visible) {
            // Caught the AI hider!
            showGameOver('üéÇ YOU WIN!', 'You caught the hider! Great job!', true);
            console.log('Caught AI hider with R key!');
          } else if (distance < 10) {
            // Too far, show hint
            console.log('Get closer to catch! (Distance: ' + distance.toFixed(1) + ')');
          }
        }
        
        // Use Camera Card with C key (for hiders and explorers)
        if (e.key.toLowerCase() === 'c' && gameStarted && (window.playerRole === 'hider' || window.playerRole === 'explorer') && cameraCardCount > 0 && !cameraCardActive) {
          cameraCardCount--;
          cameraCardActive = true;
          cameraCardTimer = 10; // 10 seconds
          console.log(`üì∑ Camera Card activated! (${cameraCardCount} remaining)`);
          
          const noiseIndicator = document.getElementById('noise-indicator');
          noiseIndicator.style.display = 'block';
          noiseIndicator.textContent = `üì∑ Camera Active! (${cameraCardCount} cards left)`;
          noiseIndicator.style.color = '#2196F3';
          setTimeout(() => {
            noiseIndicator.style.display = 'none';
          }, 2000);
        }
        
        // Use Spell Book with V key - teleport away from all cakes!
        if (e.key.toLowerCase() === 'v' && gameStarted && (window.playerRole === 'hider' || window.playerRole === 'explorer') && hasSpellBook) {
          hasSpellBook = false; // Single use
          
          // Find all cake positions
          const cakePositions = [];
          cakePositions.push(new THREE.Vector3(seeker.position.x, 0, seeker.position.z));
          teammates.forEach(teammate => {
            if (teammate.userData.isCake) {
              cakePositions.push(new THREE.Vector3(teammate.position.x, 0, teammate.position.z));
            }
          });
          
          // Find farthest safe position from ALL cakes
          let bestPosition = null;
          let maxMinDistance = 0;
          
          // Try random positions and pick the one farthest from nearest cake
          for (let i = 0; i < 50; i++) {
            const testPos = new THREE.Vector3(
              -50 + Math.random() * 100,
              camera.position.y,
              -40 + Math.random() * 80
            );
            
            // Check if not in wall
            if (!checkCollision(testPos)) {
              // Find distance to nearest cake
              let minDistToCake = Infinity;
              cakePositions.forEach(cakePos => {
                const dist = new THREE.Vector3(testPos.x, 0, testPos.z).distanceTo(cakePos);
                minDistToCake = Math.min(minDistToCake, dist);
              });
              
              // Keep position if it's farther from nearest cake
              if (minDistToCake > maxMinDistance) {
                maxMinDistance = minDistToCake;
                bestPosition = testPos;
              }
            }
          }
          
          // Teleport to best position
          if (bestPosition) {
            camera.position.copy(bestPosition);
            console.log(`üìö Spell Book used! Teleported ${maxMinDistance.toFixed(1)} units from nearest cake`);
            
            const noiseIndicator = document.getElementById('noise-indicator');
            noiseIndicator.style.display = 'block';
            noiseIndicator.textContent = 'üìö Teleported to Safety!';
            noiseIndicator.style.color = '#9C27B0';
            setTimeout(() => {
              noiseIndicator.style.display = 'none';
            }, 2000);
          }
        }
        
        // Hide with E (works for all hiding spots) OR perform ritual
        if (e.key.toLowerCase() === 'e' && gameStarted) {
          // Check if near altar with all candles
          if (candlesFound >= totalCandles && !performingRitual) {
            const distanceToAltar = camera.position.distanceTo(altarGroup.position);
            if (distanceToAltar < 3) {
              // Start ritual!
              performingRitual = true;
              ritualProgress = 0;
              console.log('‚ú® Starting Birthday Ritual...');
              
              const noiseIndicator = document.getElementById('noise-indicator');
              noiseIndicator.style.display = 'block';
              noiseIndicator.textContent = '‚ú® Performing Ritual... Hold E!';
              noiseIndicator.style.color = '#ffaa00';
            }
          }
          // Try to enter hiding spot
          else if (!isHiding) {
            // Try to enter any hiding spot
            if (nearHidingSpot && !nearHidingSpot.userData.occupied) {
              isHiding = true;
              currentLocker = nearHidingSpot;
              nearHidingSpot.userData.occupied = true;
              
              // Move camera INTO the hiding spot
              const type = nearHidingSpot.userData.type;
              const targetPos = nearHidingSpot.position.clone();
              
              if (type === 'locker' || type === 'closet' || type === 'bathroom') {
                // Inside standing
                camera.position.set(targetPos.x, targetPos.y - 0.3, targetPos.z);
              } else if (type === 'bed') {
                // Under bed (low)
                camera.position.set(targetPos.x, targetPos.y + 0.1, targetPos.z);
              } else if (type === 'curtain') {
                // Behind curtain
                camera.position.set(targetPos.x, targetPos.y - 0.5, targetPos.z);
              } else if (type === 'attic') {
                // In attic (high up)
                camera.position.set(targetPos.x, targetPos.y + 0.3, targetPos.z);
              }
              
              // Hide E hint
              document.getElementById('e-hint').style.display = 'none';
              
              console.log(`Hiding in ${type}!`);
            }
          } else {
            // Exit hiding spot
            if (currentLocker) {
              currentLocker.userData.occupied = false;
              
              // Move player to safe exit position
              const spotPos = currentLocker.position;
              const exitOffset = 3; // Move 3 units away
              
              // Try multiple directions to find safe exit
              const directions = [
                {x: exitOffset, z: 0},
                {x: -exitOffset, z: 0},
                {x: 0, z: exitOffset},
                {x: 0, z: -exitOffset}
              ];
              
              let exitFound = false;
              for (let dir of directions) {
                const testPos = new THREE.Vector3(
                  spotPos.x + dir.x,
                  originalCameraY,
                  spotPos.z + dir.z
                );
                if (!checkCollision(testPos)) {
                  camera.position.copy(testPos);
                  exitFound = true;
                  break;
                }
              }
              
              if (!exitFound) {
                // Fallback: just move up
                camera.position.set(spotPos.x, originalCameraY, spotPos.z + exitOffset);
              }
              
              currentLocker = null;
            }
            isHiding = false;
            hideTimer = 0; // Reset timer when leaving
            console.log('Left hiding spot - moved to safe position');
          }
        }
      });
      
      window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
        
        // Cancel ritual if E is released
        if (e.key.toLowerCase() === 'e' && performingRitual) {
          performingRitual = false;
          ritualProgress = 0;
          console.log('‚ùå Ritual cancelled!');
          document.getElementById('noise-indicator').style.display = 'none';
        }
        
        // Stop sprinting
        if (e.key === 'Control') {
          keys['ctrl'] = false;
        }
        // Stop sneaking
        if (e.key === 'Shift') {
          keys['shift'] = false;
        }
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Audio initialization function
      function initializeAudio() {
        try {
          // Create enhanced background music using Web Audio API
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          const audioContext = new AudioContext();
          
          // Create multiple oscillators for rich, layered atmosphere
          const bass1 = audioContext.createOscillator();
          const bass2 = audioContext.createOscillator();
          const mid1 = audioContext.createOscillator();
          const mid2 = audioContext.createOscillator();
          const high1 = audioContext.createOscillator();
          const high2 = audioContext.createOscillator();
          const ambient = audioContext.createOscillator();
          
          // Deep bass drones (ominous foundation)
          bass1.type = 'sine';
          bass1.frequency.setValueAtTime(55, audioContext.currentTime); // A1
          bass2.type = 'sine';
          bass2.frequency.setValueAtTime(58, audioContext.currentTime); // Slightly detuned for beating effect
          
          // Mid layers (unsettling harmonics)
          mid1.type = 'triangle';
          mid1.frequency.setValueAtTime(110, audioContext.currentTime); // A2
          mid2.type = 'sawtooth';
          mid2.frequency.setValueAtTime(165, audioContext.currentTime); // E3 (dissonant)
          
          // High layers (eerie presence)
          high1.type = 'sine';
          high1.frequency.setValueAtTime(220, audioContext.currentTime); // A3
          high2.type = 'sine';
          high2.frequency.setValueAtTime(329.63, audioContext.currentTime); // E4 (eerie fifth)
          
          // Ambient noise layer (atmospheric)
          ambient.type = 'sawtooth';
          ambient.frequency.setValueAtTime(40, audioContext.currentTime); // Sub-bass rumble
          
          // Create gain nodes for each layer
          const bass1Gain = audioContext.createGain();
          const bass2Gain = audioContext.createGain();
          const mid1Gain = audioContext.createGain();
          const mid2Gain = audioContext.createGain();
          const high1Gain = audioContext.createGain();
          const high2Gain = audioContext.createGain();
          const ambientGain = audioContext.createGain();
          const masterGain = audioContext.createGain();
          
          // Set volumes for balanced mix
          bass1Gain.gain.setValueAtTime(0.12, audioContext.currentTime);
          bass2Gain.gain.setValueAtTime(0.10, audioContext.currentTime);
          mid1Gain.gain.setValueAtTime(0.06, audioContext.currentTime);
          mid2Gain.gain.setValueAtTime(0.04, audioContext.currentTime);
          high1Gain.gain.setValueAtTime(0.03, audioContext.currentTime);
          high2Gain.gain.setValueAtTime(0.02, audioContext.currentTime);
          ambientGain.gain.setValueAtTime(0.08, audioContext.currentTime);
          masterGain.gain.setValueAtTime(0.25, audioContext.currentTime); // Overall volume
          
          // Create filter for ambient texture
          const filter = audioContext.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(200, audioContext.currentTime);
          filter.Q.setValueAtTime(1, audioContext.currentTime);
          
          // Connect all layers
          bass1.connect(bass1Gain);
          bass2.connect(bass2Gain);
          mid1.connect(mid1Gain);
          mid2.connect(mid2Gain);
          high1.connect(high1Gain);
          high2.connect(high2Gain);
          ambient.connect(filter);
          filter.connect(ambientGain);
          
          bass1Gain.connect(masterGain);
          bass2Gain.connect(masterGain);
          mid1Gain.connect(masterGain);
          mid2Gain.connect(masterGain);
          high1Gain.connect(masterGain);
          high2Gain.connect(masterGain);
          ambientGain.connect(masterGain);
          
          masterGain.connect(audioContext.destination);
          
          // Start all oscillators
          bass1.start();
          bass2.start();
          mid1.start();
          mid2.start();
          high1.start();
          high2.start();
          ambient.start();
          
          // Advanced modulation for dynamic atmosphere
          let modulationPhase = 0;
          setInterval(() => {
            const time = audioContext.currentTime;
            modulationPhase += 0.1;
            
            // Slow frequency drift for unease
            const drift = Math.sin(modulationPhase) * 3;
            bass1.frequency.setValueAtTime(55 + drift, time);
            bass2.frequency.setValueAtTime(58 - drift * 0.5, time);
            
            // Random variations for unpredictability
            const variation = Math.random() * 4 - 2;
            mid1.frequency.setValueAtTime(110 + variation, time);
            mid2.frequency.setValueAtTime(165 + variation * 1.5, time);
            
            // Subtle high layer movement
            const highVar = Math.sin(modulationPhase * 0.5) * 5;
            high1.frequency.setValueAtTime(220 + highVar, time);
            high2.frequency.setValueAtTime(329.63 + highVar * 1.2, time);
            
            // Pulsing ambient layer
            const pulse = 0.05 + Math.sin(modulationPhase * 2) * 0.03;
            ambientGain.gain.setValueAtTime(pulse, time);
            
            // Dynamic filter sweep
            const filterFreq = 150 + Math.sin(modulationPhase * 0.3) * 50;
            filter.frequency.setValueAtTime(filterFreq, time);
            
          }, 2000); // Update every 2 seconds
          
          // Volume breathing effect (subtle)
          let breathPhase = 0;
          setInterval(() => {
            const time = audioContext.currentTime;
            breathPhase += 0.05;
            const breath = 0.25 + Math.sin(breathPhase) * 0.03;
            masterGain.gain.setValueAtTime(breath, time);
          }, 5000); // Slow breathing cycle
          
          backgroundMusic = { audioContext, masterGain };
          console.log('üéµ Enhanced background music initialized');
          
        } catch (e) {
          console.warn('Could not initialize audio:', e);
        }
      }
      
      // Jumpscare sound function with multiple variations
      function playJumpscareSound(type = 'random') {
        try {
          if (!backgroundMusic) return;
          
          const audioContext = backgroundMusic.audioContext;
          const now = audioContext.currentTime;
          
          // Choose random type if not specified
          if (type === 'random') {
            const types = ['laugh', 'whisper', 'breathing', 'static'];
            type = types[Math.floor(Math.random() * types.length)];
          }
          
          if (type === 'laugh') {
            // Creepy descending laugh
            const laugh1 = audioContext.createOscillator();
            const laugh2 = audioContext.createOscillator();
            const laugh3 = audioContext.createOscillator();
            const laughGain = audioContext.createGain();
            
            laugh1.type = 'sawtooth';
            laugh1.frequency.setValueAtTime(800, now);
            laugh1.frequency.exponentialRampToValueAtTime(400, now + 0.3);
            
            laugh2.type = 'square';
            laugh2.frequency.setValueAtTime(600, now + 0.1);
            laugh2.frequency.exponentialRampToValueAtTime(300, now + 0.4);
            
            laugh3.type = 'triangle';
            laugh3.frequency.setValueAtTime(1000, now + 0.2);
            laugh3.frequency.exponentialRampToValueAtTime(500, now + 0.5);
            
            laughGain.gain.setValueAtTime(0, now);
            laughGain.gain.linearRampToValueAtTime(0.4, now + 0.1);
            laughGain.gain.linearRampToValueAtTime(0.3, now + 0.3);
            laughGain.gain.linearRampToValueAtTime(0, now + 0.6);
            
            laugh1.connect(laughGain);
            laugh2.connect(laughGain);
            laugh3.connect(laughGain);
            laughGain.connect(audioContext.destination);
            
            laugh1.start(now);
            laugh2.start(now + 0.1);
            laugh3.start(now + 0.2);
            laugh1.stop(now + 0.6);
            laugh2.stop(now + 0.6);
            laugh3.stop(now + 0.6);
            
            console.log('üòà Laugh jumpscare!');
            
          } else if (type === 'whisper') {
            // Eerie whisper effect (white noise with modulation)
            const whisper = audioContext.createOscillator();
            const whisperGain = audioContext.createGain();
            
            whisper.type = 'sawtooth';
            whisper.frequency.setValueAtTime(100, now);
            whisper.frequency.linearRampToValueAtTime(150, now + 0.5);
            whisper.frequency.linearRampToValueAtTime(80, now + 1.0);
            
            whisperGain.gain.setValueAtTime(0, now);
            whisperGain.gain.linearRampToValueAtTime(0.2, now + 0.2);
            whisperGain.gain.linearRampToValueAtTime(0.15, now + 0.6);
            whisperGain.gain.linearRampToValueAtTime(0, now + 1.0);
            
            whisper.connect(whisperGain);
            whisperGain.connect(audioContext.destination);
            
            whisper.start(now);
            whisper.stop(now + 1.0);
            
            console.log('üëª Whisper jumpscare!');
            
          } else if (type === 'breathing') {
            // Heavy breathing effect
            const breath = audioContext.createOscillator();
            const breathGain = audioContext.createGain();
            
            breath.type = 'sawtooth';
            breath.frequency.setValueAtTime(60, now);
            
            // Pulsing volume for breathing effect
            for (let i = 0; i < 3; i++) {
              const t = now + i * 0.4;
              breathGain.gain.setValueAtTime(0, t);
              breathGain.gain.linearRampToValueAtTime(0.25, t + 0.15);
              breathGain.gain.linearRampToValueAtTime(0, t + 0.35);
            }
            
            breath.connect(breathGain);
            breathGain.connect(audioContext.destination);
            
            breath.start(now);
            breath.stop(now + 1.2);
            
            console.log('üò∞ Breathing jumpscare!');
            
          } else if (type === 'static') {
            // Radio static/glitch effect
            const static1 = audioContext.createOscillator();
            const static2 = audioContext.createOscillator();
            const staticGain = audioContext.createGain();
            
            static1.type = 'sawtooth';
            static2.type = 'square';
            
            // Rapidly changing frequencies for glitch effect
            for (let i = 0; i < 10; i++) {
              const t = now + i * 0.05;
              const freq1 = 200 + Math.random() * 800;
              const freq2 = 300 + Math.random() * 900;
              static1.frequency.setValueAtTime(freq1, t);
              static2.frequency.setValueAtTime(freq2, t);
            }
            
            staticGain.gain.setValueAtTime(0, now);
            staticGain.gain.linearRampToValueAtTime(0.3, now + 0.05);
            staticGain.gain.linearRampToValueAtTime(0.2, now + 0.3);
            staticGain.gain.linearRampToValueAtTime(0, now + 0.5);
            
            static1.connect(staticGain);
            static2.connect(staticGain);
            staticGain.connect(audioContext.destination);
            
            static1.start(now);
            static2.start(now);
            static1.stop(now + 0.5);
            static2.stop(now + 0.5);
            
            console.log('üìª Static jumpscare!');
          }
          
        } catch (e) {
          console.warn('Could not play jumpscare sound:', e);
        }
      }
      
      // Collision detection
      function checkCollision(position) {
        // Check house boundaries (tighter)
        if (Math.abs(position.x) > houseWidth / 2 - 2 || Math.abs(position.z) > houseDepth / 2 - 2) {
          return true;
        }

        // Check collision with obstacles (but allow stairs and hiding spots)
        for (let obstacle of obstacles) {
          // Skip stairs and hiding spots for collision - allow walking through them
          if (obstacle.userData && (obstacle.userData.isStair || obstacle.userData.isHidingSpot)) {
            continue;
          }
          
          if (obstacle.geometry) {
            const box = new THREE.Box3().setFromObject(obstacle);
            // Smaller player collision box (0.6 instead of 1)
            const playerBox = new THREE.Box3().setFromCenterAndSize(
              position,
              new THREE.Vector3(0.6, 2, 0.6)
            );
            if (box.intersectsBox(playerBox)) {
              return true;
            }
          }
        }
        return false;
      }
      
      // Check if player bumps into objects (makes noise)
      function checkObjectCollision(position) {
        for (let obj of roomObjects) {
          if (obj.userData.canMakeNoise) {
            const distance = position.distanceTo(obj.position);
            if (distance < 1.5) {
              // Bumped into object - make noise!
              const currentTime = Date.now();
              if (currentTime - lastNoiseTime > 3000) { // Cooldown 3 seconds
                lastNoiseTime = currentTime;
                playerNoisePosition = camera.position.clone();
                noiseTimer = 3;
                
                // Visual feedback
                const noiseIndicator = document.getElementById('noise-indicator');
                noiseIndicator.style.display = 'block';
                noiseIndicator.textContent = `üí• Bumped into ${obj.userData.noiseName}!`;
                setTimeout(() => {
                  noiseIndicator.style.display = 'none';
                }, 1000);
                
                console.log(`Made noise by bumping ${obj.userData.noiseName}!`);
                return true;
              }
            }
          }
        }
        return false;
      }
      
      // Noise only from touching cups (removed random noise)
      function generateNoiseFromCup() {
        playerNoisePosition = camera.position.clone();
        noiseTimer = 3; // Noise lasts 3 seconds
        
        const noiseIndicator = document.getElementById('noise-indicator');
        noiseIndicator.style.display = 'block';
        noiseIndicator.textContent = 'ü•§ Knocked a cup!';
        setTimeout(() => {
          noiseIndicator.style.display = 'none';
        }, 1000);
        
        console.log('Made noise by touching cup!');
      }

      // Animation loop
      let frameCount = 0;
      function animate() {
        requestAnimationFrame(animate);
        frameCount++;
        
        // Debug: Log every 60 frames (about 1 second)
        if (frameCount % 60 === 0) {
          console.log('Animate running. Frame:', frameCount, 'hidingPhase:', hidingPhase, 'hideTime:', Math.floor(hideTime));
        }
        
        // Update ritual progress
        if (performingRitual && keys['e']) {
          ritualProgress += 0.016; // Add time
          
          // Update progress display
          const progress = Math.floor((ritualProgress / RITUAL_TIME) * 100);
          const noiseIndicator = document.getElementById('noise-indicator');
          noiseIndicator.textContent = `‚ú® Ritual Progress: ${progress}% (Hold E)`;
          
          // Pulse altar glow
          const glowIntensity = 0.8 + Math.sin(Date.now() / 100) * 0.4;
          altarGroup.children[2].material.emissiveIntensity = glowIntensity;
          
          // Complete ritual!
          if (ritualProgress >= RITUAL_TIME) {
            performingRitual = false;
            console.log('üéâ RITUAL COMPLETE! YOU WIN!');
            showGameOver('üéâ YOU WIN!', 'You performed the Birthday Ritual and broke the curse!', true);
            return;
          }
        }
        
        // Check if near tool (for collection - hiders and explorers)
        if (gameStarted && (window.playerRole === 'hider' || window.playerRole === 'explorer')) {
          for (let tool of tools) {
            if (!tool.userData.collected) {
              const distance = camera.position.distanceTo(tool.position);
              if (distance < 2) {
                // Collect tool!
                tool.userData.collected = true;
                const toolType = tool.userData.toolType;
                const toolName = tool.userData.toolName;
                
                if (toolType === 'camera') {
                  cameraCardCount++;
                  console.log(`üì∑ Camera Card collected! (${cameraCardCount}/2) Press [C] to use`);
                } else if (toolType === 'shield') {
                  hasSpellBook = true;
                  console.log('üìö Spell Book collected! Press [V] to teleport away from danger');
                }
                
                // Remove tool from scene
                scene.remove(tool);
                
                // Visual feedback
                const noiseIndicator = document.getElementById('noise-indicator');
                noiseIndicator.style.display = 'block';
                noiseIndicator.textContent = `${toolName} Collected!`;
                noiseIndicator.style.color = '#00ff00';
                setTimeout(() => {
                  noiseIndicator.style.display = 'none';
                }, 2000);
              }
              
              // Rotation animation for tools
              tool.rotation.y += tool.userData.rotationSpeed;
            }
          }
          
          // Check if near candle (for collection)
          for (let candle of candles) {
            if (!candle.userData.collected) {
              const distance = camera.position.distanceTo(candle.position);
              if (distance < 2) {
                // Collect candle!
                candle.userData.collected = true;
                candlesFound++;
                console.log('üïØÔ∏è Candle collected! (' + candlesFound + '/' + totalCandles + ')');
                
                // Remove candle from scene
                scene.remove(candle);
                
                // === SPAWN EXTRA CAKE AT 2 CANDLES ===
                if (candlesFound === 2 && !window.extraCakeSpawned) {
                  window.extraCakeSpawned = true;
                  
                  // Create extra cake (pink, like teammate cakes)
                  const extraCake = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1.5, 1),
                    new THREE.MeshStandardMaterial({ 
                      color: 0xff69b4,
                      emissive: 0xff1493,
                      emissiveIntensity: 0.3
                    })
                  );
                  
                  // Spawn in random bottom room (Study, Kitchen, or Hall)
                  const spawnLocations = [
                    {x: -35, z: 20},  // Study
                    {x: 0, z: 10},    // Kitchen
                    {x: 0, z: 27}     // Hall
                  ];
                  const spawnPos = spawnLocations[Math.floor(Math.random() * spawnLocations.length)];
                  extraCake.position.set(spawnPos.x, 0.75, spawnPos.z);
                  extraCake.castShadow = true;
                  extraCake.receiveShadow = true;
                  scene.add(extraCake);
                  
                  // Add to teammates array for AI behavior
                  const teammate = {
                    mesh: extraCake,
                    position: extraCake.position,
                    userData: { 
                      isCake: true, 
                      caughtPlayer: null,
                      isExtraCake: true,  // Mark as extra cake
                      cakeSpeed: 0.05     // Movement speed
                    }
                  };
                  extraCake.userData.isCake = true;
                  extraCake.userData.caughtPlayer = null;
                  extraCake.userData.isExtraCake = true;
                  extraCake.userData.cakeSpeed = 0.05;
                  teammates.push(teammate);
                  
                  console.log('üéÇ EXTRA CAKE SPAWNED! Footpath locked to bottom 3 rooms!');
                  
                  // Show warning
                  const noiseIndicator = document.getElementById('noise-indicator');
                  noiseIndicator.style.display = 'block';
                  noiseIndicator.textContent = '‚ö†Ô∏è ANOTHER CAKE APPEARED! IT\'S HUNTING THE BOTTOM ROOMS!';
                  noiseIndicator.style.color = '#ff1493';
                  setTimeout(() => {
                    noiseIndicator.style.display = 'none';
                  }, 5000);
                }
                
                // Check if all candles collected (but not win yet!)
                if (candlesFound >= totalCandles) {
                  console.log('‚úÖ All candles collected! Go to the altar to perform the ritual!');
                  const noiseIndicator = document.getElementById('noise-indicator');
                  noiseIndicator.style.display = 'block';
                  noiseIndicator.textContent = '‚ú® All Candles Found! Go to the Altar!';
                  noiseIndicator.style.color = '#ffaa00';
                  setTimeout(() => {
                    noiseIndicator.style.display = 'none';
                  }, 4000);
                }
                
                // Play collection sound (visual feedback)
                const noiseIndicator = document.getElementById('noise-indicator');
                noiseIndicator.style.display = 'block';
                noiseIndicator.textContent = 'üïØÔ∏è Candle Found! (' + candlesFound + '/' + totalCandles + ')';
                noiseIndicator.style.color = '#ffaa00';
                setTimeout(() => {
                  noiseIndicator.style.display = 'none';
                }, 2000);
              }
              
              // Pulse animation for candles
              candle.userData.pulseTime += 0.05;
              const scale = 1 + Math.sin(candle.userData.pulseTime) * 0.1;
              candle.children[1].scale.set(scale, scale, scale); // Flame pulsing
            }
          }
        }
        
        // Check if near altar (for ritual)
        if (gameStarted && candlesFound >= totalCandles && !performingRitual) {
          const distanceToAltar = camera.position.distanceTo(altarGroup.position);
          if (distanceToAltar < 3) {
            document.getElementById('e-hint').textContent = 'Press [E] to Perform Birthday Ritual';
            document.getElementById('e-hint').style.display = 'block';
          } else if (distanceToAltar < 10) {
            document.getElementById('e-hint').textContent = '‚Üí Go to the Altar (Center)';
            document.getElementById('e-hint').style.display = 'block';
          }
        }
        
        // Check if near hiding spot (for E hint)
        if (gameStarted && !isHiding) {
          nearHidingSpot = null;
          for (let spot of hidingSpots) {
            const distance = camera.position.distanceTo(spot.position);
            if (distance < 3 && !spot.userData.occupied) {
              nearHidingSpot = spot;
              const type = spot.userData.type;
              document.getElementById('e-hint').textContent = `Press [E] to Hide in ${type.charAt(0).toUpperCase() + type.slice(1)}`;
              document.getElementById('e-hint').style.display = 'block';
              break;
            }
          }
          if (!nearHidingSpot) {
            document.getElementById('e-hint').style.display = 'none';
          }
        } else {
          document.getElementById('e-hint').style.display = 'none';
        }
        
        // Check if near AI hider (for R hint in seeker mode)
        if (gameStarted && window.playerRole === 'seeker' && aiHider.visible) {
          const playerPos = new THREE.Vector3(camera.position.x, 0, camera.position.z);
          const hiderPos = new THREE.Vector3(aiHider.position.x, 0, aiHider.position.z);
          const distance = playerPos.distanceTo(hiderPos);
          
          if (distance < 3) {
            document.getElementById('r-hint').style.display = 'block';
          } else {
            document.getElementById('r-hint').style.display = 'none';
          }
        } else {
          document.getElementById('r-hint').style.display = 'none';
        }

        // Movement controls with collision
        if (controls.isLocked) {
          const prevPosition = camera.position.clone();
          
          // Debug: Log movement attempts
          if (keys['w'] || keys['s'] || keys['a'] || keys['d']) {
            console.log('Trying to move. Keys:', {w: keys['w'], s: keys['s'], a: keys['a'], d: keys['d']});
            console.log('Current position:', camera.position);
            console.log('isHiding:', isHiding);
          }
          
          // Can't move position while hiding (but can still look around)
          if (!isHiding) {
          
          // GRADUAL VOLUME BUILDUP SYSTEM
          const isSprinting = keys['ctrl'] && keys['w'];
          const isSneaking = keys['shift'];
          const isMoving = keys['w'] || keys['s'] || keys['a'] || keys['d'];
          
          // Set movement speed
          if (isSneaking) {
            currentSpeed = sneakSpeed; // Sneaking (Shift)
          } else if (isSprinting) {
            currentSpeed = sprintSpeed; // Sprinting (Ctrl + W)
          } else {
            currentSpeed = walkSpeed; // Normal walking
          }
          
          // Gradually increase volume while moving
          if (isMoving) {
            if (isSneaking) {
              volumeLevel += 0.05; // VERY slow buildup when sneaking
            } else if (isSprinting) {
              volumeLevel += 2.0; // Fast buildup when sprinting
            } else {
              volumeLevel += 0.8; // Medium buildup when walking
            }
            volumeLevel = Math.min(volumeLevel, 100); // Cap at 100
          } else {
            // Gradually decrease when standing still
            volumeLevel -= 1.5;
            volumeLevel = Math.max(volumeLevel, 0); // Floor at 0
          }
          
          // Calculate detection threshold based on distance to cake
          const playerPos2D = new THREE.Vector3(camera.position.x, 0, camera.position.z);
          const seekerPos2D = new THREE.Vector3(seeker.position.x, 0, seeker.position.z);
          const distanceToSeeker = playerPos2D.distanceTo(seekerPos2D);
          
          // Threshold decreases when near ANY cake (main cake OR teammate cakes)
          let minThreshold = 100;
          
          // Check main cake
          if (distanceToSeeker < 30) {
            const cakeThreshold = 100 - ((30 - distanceToSeeker) / 30) * 70; // 30 to 100
            minThreshold = Math.min(minThreshold, cakeThreshold);
          }
          
          // Check teammate cakes
          teammates.forEach(teammate => {
            if (teammate.userData.isCake) {
              const teammatePos = new THREE.Vector3(teammate.position.x, 0, teammate.position.z);
              const distToTeammateCake = playerPos2D.distanceTo(teammatePos);
              if (distToTeammateCake < 30) {
                const teammateThreshold = 100 - ((30 - distToTeammateCake) / 30) * 70; // 30 to 100
                minThreshold = Math.min(minThreshold, teammateThreshold);
              }
            }
          });
          
          detectionThreshold = Math.max(minThreshold, 30); // Minimum 30
          
          // Get spotted if volume exceeds threshold - CAKE TELEPORTS TO YOU!
          if (!hidingPhase && volumeLevel >= detectionThreshold && !isHiding) {
            // Too loud! Cake teleports near you (but only once per chase)
            if (seekerState !== 'chase' && !cakeAlreadyTeleported) {
              // Teleport cake just outside player's vision
              const playerPos = new THREE.Vector3(camera.position.x, 0, camera.position.z);
              
              // Get camera forward direction (where player is looking)
              const cameraDirection = new THREE.Vector3();
              camera.getWorldDirection(cameraDirection);
              cameraDirection.y = 0;
              cameraDirection.normalize();
              
              // Try positions behind player or to the sides (outside vision)
              const possibleAngles = [
                Math.PI,        // Directly behind
                Math.PI * 0.75, // Behind-left
                Math.PI * 1.25, // Behind-right
                Math.PI * 0.6,  // Side-left
                Math.PI * 1.4   // Side-right
              ];
              
              let bestPosition = null;
              const spawnDistance = 15; // 15 units away
              
              // Try each angle and pick first valid position
              for (let angleOffset of possibleAngles) {
                // Calculate angle relative to camera direction
                const cameraAngle = Math.atan2(cameraDirection.x, cameraDirection.z);
                const finalAngle = cameraAngle + angleOffset;
                
                const testPos = new THREE.Vector3(
                  playerPos.x + Math.sin(finalAngle) * spawnDistance,
                  1.5,
                  playerPos.z + Math.cos(finalAngle) * spawnDistance
                );
                
                // Check if not in wall
                if (!checkCollision(testPos)) {
                  bestPosition = testPos;
                  break;
                }
              }
              
              // Teleport cake to position
              if (bestPosition) {
                seeker.position.copy(bestPosition);
                seekerState = 'chase';
                cakeAlreadyTeleported = true;
                console.log('üö® TOO LOUD! Cake teleported near you and is chasing!');
                
                const noiseIndicator = document.getElementById('noise-indicator');
                noiseIndicator.style.display = 'block';
                noiseIndicator.textContent = 'üö® CAKE HEARD YOU! IT\'S COMING!';
                noiseIndicator.style.color = '#ff0000';
                setTimeout(() => {
                  noiseIndicator.style.display = 'none';
                }, 3000);
              }
            }
          }
          
          if (keys['w']) {
            controls.moveForward(currentSpeed);
            if (checkCollision(camera.position)) {
              camera.position.copy(prevPosition);
              console.log('Collision detected moving forward');
            }
          }
          if (keys['s']) {
            controls.moveForward(-currentSpeed);
            if (checkCollision(camera.position)) {
              camera.position.copy(prevPosition);
              console.log('Collision detected moving backward');
            }
          }
          if (keys['a']) {
            controls.moveRight(-currentSpeed);
            if (checkCollision(camera.position)) {
              camera.position.copy(prevPosition);
              console.log('Collision detected moving left');
            }
          }
          if (keys['d']) {
            controls.moveRight(currentSpeed);
            if (checkCollision(camera.position)) {
              camera.position.copy(prevPosition);
              console.log('Collision detected moving right');
            }
          }
          
          // No stairs - single floor only
          
          // Check if touching cups (make noise)
          const moving = keys['w'] || keys['s'] || keys['a'] || keys['d'];
          if (moving && !isHiding) {
            // Check collision with cups
            for (let obj of roomObjects) {
              if (obj.userData.noiseName === 'cup') {
                const distance = camera.position.distanceTo(obj.position);
                if (distance < 1.5) {
                  // Touched a cup - make noise!
                  const now = Date.now();
                  if (now - lastNoiseTime > 2000) { // Cooldown 2 seconds
                    generateNoiseFromCup();
                    lastNoiseTime = now;
                  }
                  break;
                }
              }
            }
          }
          
          if (moving) {
            if (!isWalking) {
              isWalking = true;
              walkingSoundTime = Date.now();
            }
            
            // Camera shake based on movement type (head bob)
            walkCycle += isSprinting ? 0.2 : (isSneaking ? 0.05 : 0.1);
            const shakeIntensity = isSprinting ? 0.08 : (isSneaking ? 0.015 : 0.04);
            
            // Apply vertical head bob (camera shake) and lower camera when sneaking
            const baseHeight = isSneaking ? sneakCameraY : originalCameraY;
            camera.position.y = baseHeight + Math.sin(walkCycle) * shakeIntensity;
            
            // Play footstep sound at intervals
            const currentTime = Date.now();
            let stepInterval, footstepVolume;
            
            if (isSneaking) {
              stepInterval = 700; // Slower, quieter steps
              footstepVolume = 0.15; // Much quieter
            } else if (isSprinting) {
              stepInterval = 300; // Fast steps
              footstepVolume = 0.5; // Louder
            } else {
              stepInterval = 500; // Normal walking
              footstepVolume = 0.35; // Normal volume
            }
            
            if (currentTime - walkingSoundTime > stepInterval) {
              // Create realistic footstep sound using noise
              const footstepContext = listener.context;
              const bufferSize = footstepContext.sampleRate * 0.15; // 150ms footstep
              const footstepBuffer = footstepContext.createBuffer(1, bufferSize, footstepContext.sampleRate);
              const footstepData = footstepBuffer.getChannelData(0);
              
              // Generate realistic footstep with filtered noise
              for (let i = 0; i < bufferSize; i++) {
                const t = i / bufferSize;
                // White noise
                const noise = (Math.random() - 0.5) * 2;
                // Envelope (quick attack, decay)
                const envelope = Math.exp(-t * 15) * (1 - Math.exp(-t * 50));
                // Low-pass filter effect (footstep on floor)
                footstepData[i] = noise * envelope * 0.3;
              }
              
              const footstepSource = footstepContext.createBufferSource();
              footstepSource.buffer = footstepBuffer;
              
              const footstepGain = footstepContext.createGain();
              footstepGain.gain.value = footstepVolume;
              
              footstepSource.connect(footstepGain);
              footstepGain.connect(footstepContext.destination);
              
              footstepSource.start(footstepContext.currentTime);
              
              walkingSoundTime = currentTime;
            }
          } else {
            isWalking = false;
            walkCycle = 0;
            // Reset camera to original height when not moving
            camera.position.y = originalCameraY;
          }
          } // End of if (!isHiding) block
        }

        // Calculate distance to seeker (used in multiple places)
        const playerPos = new THREE.Vector3(camera.position.x, 0, camera.position.z);
        const seekerPos2D = new THREE.Vector3(seeker.position.x, 0, seeker.position.z);
        const distanceToPlayer = playerPos.distanceTo(seekerPos2D);
        
        // === AI SEEKER LOGIC (Active for hider and explorer/debug mode, not in creative mode) ===
        if (!hidingPhase && (window.playerRole === 'hider' || window.playerRole === 'explorer') && gameMode !== 'creative') {
        
        // Update spotted chase timer - rush mode like Granny
        if (spottedChaseTimer > 0) {
          spottedChaseTimer -= 0.016;
          if (spottedChaseTimer <= 0) {
            cakeRushMode = false;
            console.log('‚è∞ Rush mode ended - cake back to normal speed');
          }
        }
        
        if (noiseTimer > 0) {
          noiseTimer -= 0.016;
          if (noiseTimer <= 0) {
            playerNoisePosition = null;
          }
        }
        
        // Update seeker behavior
        // Reset teleport flag when cake returns to patrol
        if (seekerState === 'patrol') {
          cakeAlreadyTeleported = false;
          // Move to waypoint (including vertical movement for stairs)
          const targetWaypoint = seekerWaypoints[seekerWaypoint];
          const seekerPos3D = new THREE.Vector3(seeker.position.x, seeker.position.y - 1.5, seeker.position.z);
          const direction = new THREE.Vector3().subVectors(targetWaypoint, seekerPos3D).normalize();
          
          // Check collision before moving
          const newSeekerPos = new THREE.Vector3(
            seeker.position.x + direction.x * seekerSpeed,
            0,
            seeker.position.z + direction.z * seekerSpeed
          );
          
          const seekerCollision = checkCollision(newSeekerPos);
          if (!seekerCollision) {
            seeker.position.x += direction.x * seekerSpeed;
            seeker.position.z += direction.z * seekerSpeed;
            // Smoothly move between floors
            seeker.position.y += direction.y * seekerSpeed;
          } else {
            // Skip to next waypoint if stuck
            seekerWaypoint = (seekerWaypoint + 1) % seekerWaypoints.length;
          }
          
          // Check if reached waypoint
          if (seekerPos3D.distanceTo(targetWaypoint) < 2) {
            seekerWaypoint = (seekerWaypoint + 1) % seekerWaypoints.length;
          }
          
          // Check for nearest target (player or teammates)
          let nearestTarget = null;
          let nearestDist = distanceToPlayer;
          let targetIsPlayer = true;
          
          // Check if player is valid target
          if (!isHiding) {
            nearestTarget = playerPos;
            nearestDist = distanceToPlayer;
          }
          
          // Check teammates as potential targets (ONLY if player not available)
          if (!targetIsPlayer || nearestDist > 30) {
            // Only chase teammates if player is far or not detected
            teammates.forEach(teammate => {
              if (!teammate.userData.isCaught && !teammate.userData.isHiding) {
                const teammatePos = new THREE.Vector3(teammate.position.x, 0, teammate.position.z);
                const dist = seekerPos2D.distanceTo(teammatePos);
                // Only chase teammates if within 20 units AND player not closer
                if (dist < 20 && dist < nearestDist) {
                  nearestTarget = teammatePos;
                  nearestDist = dist;
                  targetIsPlayer = false;
                }
              }
            });
          }
          
          // Check if player is spotted (auto-spotted from sprinting)
          if (isSpotted && distanceToPlayer < 25 && !isHiding) {
            seekerState = 'chase';
            
            // Show spotted warning
            const spottedWarning = document.getElementById('spotted-warning');
            spottedWarning.style.display = 'block';
          }
          // Check if heard noise
          else if (playerNoisePosition && seekerPos2D.distanceTo(new THREE.Vector3(playerNoisePosition.x, 0, playerNoisePosition.z)) < 20) {
            seekerState = 'search';
          }
          // Check if any target is visible and close
          else if (nearestTarget && nearestDist < 15) {
            seekerState = 'chase';
            
            // Show spotted warning if chasing player
            if (targetIsPlayer) {
              const spottedWarning = document.getElementById('spotted-warning');
              spottedWarning.style.display = 'block';
              
              // Jumpscare removed
            }
          }
        } else if (seekerState === 'chase') {
          // Find nearest target (player or teammate)
          let chaseTarget = playerPos;
          let chaseDist = distanceToPlayer;
          let chasingPlayer = true;
          let caughtTeammate = null;
          
          if (isHiding) {
            chaseTarget = null;
            chaseDist = Infinity;
            chasingPlayer = false;
          }
          
          // Check teammates
          teammates.forEach(teammate => {
            if (!teammate.userData.isCaught && !teammate.userData.isHiding) {
              const teammatePos = new THREE.Vector3(teammate.position.x, 0, teammate.position.z);
              const dist = seekerPos2D.distanceTo(teammatePos);
              if (dist < chaseDist) {
                chaseTarget = teammatePos;
                chaseDist = dist;
                chasingPlayer = false;
                caughtTeammate = teammate;
              }
            }
          });
          
          if (chaseTarget) {
            // Chase nearest target - can phase through walls if spotted!
            const direction = new THREE.Vector3().subVectors(chaseTarget, seekerPos2D).normalize();
            const newSeekerPos = seeker.position.clone();
            newSeekerPos.x += direction.x * seekerChaseSpeed;
            newSeekerPos.z += direction.z * seekerChaseSpeed;
            
            // Normal collision check
            const seekerCollision = checkCollision(new THREE.Vector3(newSeekerPos.x, 0, newSeekerPos.z));
            if (!seekerCollision) {
              seeker.position.x = newSeekerPos.x;
              seeker.position.z = newSeekerPos.z;
            }
            
            // Check if caught teammate
            if (!chasingPlayer && caughtTeammate && chaseDist < 3) {
              caughtTeammate.userData.isCaught = true;
              caughtTeammate.userData.isCake = true;
              console.log('üíÄ ' + caughtTeammate.userData.name + ' was caught by cake!');
              
              // Visual feedback
              const noiseIndicator = document.getElementById('noise-indicator');
              noiseIndicator.style.display = 'block';
              noiseIndicator.textContent = 'üéÇ ' + caughtTeammate.userData.name + ' became a cake!';
              noiseIndicator.style.color = '#ff6600';
              setTimeout(() => {
                noiseIndicator.style.display = 'none';
              }, 3000);
              
              // Transform teammate into cake visually
              caughtTeammate.children.forEach(child => {
                if (child.material) {
                  child.material.color.setHex(0xff69b4);
                  child.material.emissive.setHex(0xff1493);
                  child.material.emissiveIntensity = 0.3;
                }
              });
              
              // Initialize cake AI
              caughtTeammate.userData.cakeWaypoint = Math.floor(Math.random() * seekerWaypoints.length);
              caughtTeammate.userData.cakeSpeed = 0.03;
              
              // Return to patrol
              seekerState = 'patrol';
            }
          } else {
            // No valid target, return to patrol
            seekerState = 'patrol';
          }
          
          // Caught player (not in hiding)
          if (chasingPlayer && distanceToPlayer < 2 && !isHiding) {
            if (window.playerRole !== 'explorer') {
              showGameOver('üíÄ GAME OVER', 'You were caught by the seeker!', false);
              return;
            } else {
              console.log('üõ°Ô∏è Debug mode: Prevented death from seeker');
              // Push player away in debug mode
              const pushDirection = new THREE.Vector3().subVectors(playerPos, seekerPos2D).normalize();
              camera.position.x += pushDirection.x * 5;
              camera.position.z += pushDirection.z * 5;
              seekerState = 'patrol';
            }
          }
          
          // Check hiding spots (AI can open them!)
          if (Math.random() < 0.02) { // 2% chance per frame to check nearby spots
            for (let spot of hidingSpots) {
              const distanceToSpot = seekerPos2D.distanceTo(new THREE.Vector3(spot.position.x, 0, spot.position.z));
              if (distanceToSpot < 5 && !checkingSpot) {
                // Start checking this spot
                seekerState = 'checking';
                checkingSpot = spot;
                checkingTime = 10 + Math.random() * 5; // 10-15 seconds to investigate
                console.log(`Seeker is investigating ${spot.userData.type} for ${checkingTime.toFixed(1)} seconds...`);
                break;
              }
            }
          }
          
          // Lost player
          if (distanceToPlayer > 35 || (isHiding && distanceToPlayer > 5)) {
            seekerState = 'patrol';
            
            // Hide spotted warning
            const spottedWarning = document.getElementById('spotted-warning');
            spottedWarning.style.display = 'none';
          }
        } else if (seekerState === 'checking') {
          // AI is investigating a hiding spot (but CAN'T open it!)
          if (checkingSpot) {
            checkingTime -= 0.016;
            
            // Move toward spot
            const spotPos = new THREE.Vector3(checkingSpot.position.x, 0, checkingSpot.position.z);
            const direction = new THREE.Vector3().subVectors(spotPos, seekerPos2D).normalize();
            const newSeekerPos = new THREE.Vector3(
              seeker.position.x + direction.x * (seekerSpeed * 0.5),
              0,
              seeker.position.z + direction.z * (seekerSpeed * 0.5)
            );
            
            const seekerCollision = checkCollision(newSeekerPos);
            if (!seekerCollision) {
              seeker.position.x += direction.x * (seekerSpeed * 0.5);
              seeker.position.z += direction.z * (seekerSpeed * 0.5);
            }
            
            // Stay near spot for 10-15 seconds but DON'T open it
            // Cake can't open hiding spots anymore!
            
            // Finished checking
            if (checkingTime <= 0) {
              checkingSpot = null;
              seekerState = 'patrol';
              console.log('Seeker finished investigating spot (cannot open).');
            }
          } else {
            seekerState = 'patrol';
          }
        } else if (seekerState === 'search') {
          // Move toward last noise position - like Granny pathfinding
          if (playerNoisePosition) {
            const noisePos = new THREE.Vector3(playerNoisePosition.x, 0, playerNoisePosition.z);
            const distToNoise = seekerPos2D.distanceTo(noisePos);
            
            // If not at noise location yet, move toward it
            if (distToNoise > 3) {
              const direction = new THREE.Vector3().subVectors(noisePos, seekerPos2D).normalize();
              
              // Use 3x speed if in rush mode (far from target), normal speed when close
              let moveSpeed = seekerSpeed;
              if (cakeRushMode && distToNoise > 10) {
                // Far from target - rush at 3x speed (VERY FAST!)
                moveSpeed = seekerSpeed * 3;
              }
              
              const newSeekerPos = new THREE.Vector3(
                seeker.position.x + direction.x * moveSpeed,
                0,
                seeker.position.z + direction.z * moveSpeed
              );
              
              const seekerCollision = checkCollision(newSeekerPos);
              if (!seekerCollision) {
                seeker.position.x += direction.x * moveSpeed;
                seeker.position.z += direction.z * moveSpeed;
              } else {
                // Blocked! Try alternate paths
                // Try moving along X axis only
                const altPosX = new THREE.Vector3(
                  seeker.position.x + direction.x * moveSpeed,
                  0,
                  seeker.position.z
                );
                if (!checkCollision(altPosX)) {
                  seeker.position.x = altPosX.x;
                } else {
                  // Try moving along Z axis only
                  const altPosZ = new THREE.Vector3(
                    seeker.position.x,
                    0,
                    seeker.position.z + direction.z * moveSpeed
                  );
                  if (!checkCollision(altPosZ)) {
                    seeker.position.z = altPosZ.z;
                  } else {
                    // Try diagonal alternatives
                    const angles = [45, -45, 90, -90, 135, -135];
                    for (let angle of angles) {
                      const rad = (angle * Math.PI) / 180;
                      const cos = Math.cos(rad);
                      const sin = Math.sin(rad);
                      const rotatedDir = new THREE.Vector3(
                        direction.x * cos - direction.z * sin,
                        0,
                        direction.x * sin + direction.z * cos
                      );
                      const testPos = new THREE.Vector3(
                        seeker.position.x + rotatedDir.x * moveSpeed,
                        0,
                        seeker.position.z + rotatedDir.z * moveSpeed
                      );
                      if (!checkCollision(testPos)) {
                        seeker.position.x = testPos.x;
                        seeker.position.z = testPos.z;
                        break;
                      }
                    }
                  }
                }
              }
            } else {
              // Reached noise location - stay here for 10-15 seconds
              if (searchingTime === 0) {
                // Just arrived, set random search time (10-15 seconds)
                searchingTime = 10 + Math.random() * 5;
                console.log(`üéÇ Cake investigating noise location for ${searchingTime.toFixed(1)} seconds...`);
              }
              
              searchingTime -= 0.016; // Decrease timer
              
              // Finished searching
              if (searchingTime <= 0) {
                seekerState = 'patrol';
                cakeAlreadyTeleported = false; // Reset for next time
                playerNoisePosition = null;
                searchingTime = 0;
                console.log('üéÇ Cake finished investigating.');
              }
            }
          } else {
            seekerState = 'patrol';
            searchingTime = 0;
          }
          
          // Spot player if close
          if (distanceToPlayer < 10 && !isHiding) {
            seekerState = 'chase';
            searchingTime = 0; // Reset search timer
          }
        }
        
          // Update seeker flashlight and vision light
          seekerFlashlight.position.set(seeker.position.x, seeker.position.y + 0.5, seeker.position.z);
          seekerVisionLight.position.set(seeker.position.x, seeker.position.y, seeker.position.z);
          seekerTarget.position.set(
            seeker.position.x + (playerPos.x - seekerPos2D.x) * 0.1,
            1,
            seeker.position.z + (playerPos.z - seekerPos2D.z) * 0.1
          );
        } else {
          // Seeker is frozen during hiding phase
          seeker.visible = false;
          seekerFlashlight.visible = false;
        }
        
        // === AI TEAMMATES AUTO-HIDE BEHAVIOR ===
        if (window.playerRole === 'hider' || window.playerRole === 'explorer') {
          // Teammates wander when not hiding (even during hiding phase)
          teammates.forEach(teammate => {
            if (!teammate.userData.isHiding) {
              // Random wandering movement
              const teammatePos = new THREE.Vector3(teammate.position.x, 0, teammate.position.z);
              
              // Check if reached target or need new target
              if (!teammate.userData.wanderTarget) {
                teammate.userData.wanderTarget = new THREE.Vector3(
                  (Math.random() - 0.5) * 100,
                  0,
                  (Math.random() - 0.5) * 80
                );
              }
              
              const distToTarget = teammatePos.distanceTo(teammate.userData.wanderTarget);
              
              // If close to target, pick new target
              if (distToTarget < 2) {
                teammate.userData.wanderTarget = new THREE.Vector3(
                  (Math.random() - 0.5) * 100,
                  0,
                  (Math.random() - 0.5) * 80
                );
              }
              
              // Move towards wander target
              const direction = new THREE.Vector3().subVectors(teammate.userData.wanderTarget, teammatePos).normalize();
              teammate.position.x += direction.x * 0.03;
              teammate.position.z += direction.z * 0.03;
              
              // Rotate to face direction
              teammate.rotation.y = Math.atan2(direction.x, direction.z);
            }
          });
          
          // Caught teammates become cakes and hunt player!
          teammates.forEach((teammate, index) => {
            if (teammate.userData.isCake) {
              // This teammate is now a cake - hunt the player!
              const teammatePos = new THREE.Vector3(teammate.position.x, 0, teammate.position.z);
              const playerPos2D = new THREE.Vector3(camera.position.x, 0, camera.position.z);
              const distanceToPlayer = teammatePos.distanceTo(playerPos2D);
              
              // Initialize cake state if not set
              if (!teammate.userData.cakeState) {
                teammate.userData.cakeState = 'patrol';
                teammate.userData.searchingTime = 0;
              }
              
              // Check if should investigate noise
              if (playerNoisePosition && teammate.userData.cakeState === 'patrol') {
                const distToNoise = teammatePos.distanceTo(new THREE.Vector3(playerNoisePosition.x, 0, playerNoisePosition.z));
                if (distToNoise < 30) {
                  teammate.userData.cakeState = 'search';
                  console.log(teammate.userData.name + ' heard noise, investigating!');
                }
              }
              
              // Search behavior - investigate noise location
              if (teammate.userData.cakeState === 'search' && playerNoisePosition) {
                const noisePos = new THREE.Vector3(playerNoisePosition.x, 0, playerNoisePosition.z);
                const distToNoise = teammatePos.distanceTo(noisePos);
                
                if (distToNoise > 3) {
                  // Move toward noise - 3x speed if far, normal if close
                  const direction = new THREE.Vector3().subVectors(noisePos, teammatePos).normalize();
                  let moveSpeed = teammate.userData.cakeSpeed;
                  if (cakeRushMode && distToNoise > 10) {
                    moveSpeed = teammate.userData.cakeSpeed * 3;
                  }
                  const newPos = new THREE.Vector3(
                    teammate.position.x + direction.x * moveSpeed,
                    0,
                    teammate.position.z + direction.z * moveSpeed
                  );
                  
                  // Extra cake restricted to bottom 3 rooms
                  let canMove = !checkCollision(newPos);
                  if (teammate.userData.isExtraCake) {
                    // Bottom 3 rooms: Study (x: -45 to -25, z: 13 to 30), Kitchen (x: -25 to 25, z: 0 to 30), Hall (x: -25 to 25, z: 20 to 35)
                    const inBottomRooms = (newPos.z >= 0) && (newPos.z <= 35) && (newPos.x >= -45) && (newPos.x <= 45);
                    canMove = canMove && inBottomRooms;
                  }
                  
                  if (canMove) {
                    teammate.position.x = newPos.x;
                    teammate.position.z = newPos.z;
                  } else {
                    // Blocked! Try alternate paths
                    const altPosX = new THREE.Vector3(
                      teammate.position.x + direction.x * moveSpeed,
                      0,
                      teammate.position.z
                    );
                    if (!checkCollision(altPosX)) {
                      teammate.position.x = altPosX.x;
                    } else {
                      const altPosZ = new THREE.Vector3(
                        teammate.position.x,
                        0,
                        teammate.position.z + direction.z * moveSpeed
                      );
                      if (!checkCollision(altPosZ)) {
                        teammate.position.z = altPosZ.z;
                      } else {
                        // Try diagonal alternatives
                        const angles = [45, -45, 90, -90];
                        for (let angle of angles) {
                          const rad = (angle * Math.PI) / 180;
                          const cos = Math.cos(rad);
                          const sin = Math.sin(rad);
                          const rotatedDir = new THREE.Vector3(
                            direction.x * cos - direction.z * sin,
                            0,
                            direction.x * sin + direction.z * cos
                          );
                          const testPos = new THREE.Vector3(
                            teammate.position.x + rotatedDir.x * moveSpeed,
                            0,
                            teammate.position.z + rotatedDir.z * moveSpeed
                          );
                          if (!checkCollision(testPos)) {
                            teammate.position.x = testPos.x;
                            teammate.position.z = testPos.z;
                            break;
                          }
                        }
                      }
                    }
                  }
                  teammate.rotation.y = Math.atan2(direction.x, direction.z);
                } else {
                  // Arrived - search for 10-15 seconds
                  if (teammate.userData.searchingTime === 0) {
                    teammate.userData.searchingTime = 10 + Math.random() * 5;
                    console.log(teammate.userData.name + ' searching noise location for ' + teammate.userData.searchingTime.toFixed(1) + ' seconds...');
                  }
                  
                  teammate.userData.searchingTime -= 0.016;
                  
                  if (teammate.userData.searchingTime <= 0) {
                    teammate.userData.cakeState = 'patrol';
                    teammate.userData.searchingTime = 0;
                    console.log(teammate.userData.name + ' finished searching');
                  }
                }
                
                // Can still spot player if very close during search
                if (distanceToPlayer < 10 && !isHiding) {
                  teammate.userData.cakeState = 'chase';
                }
              }
              // Chase player if close enough
              else if (distanceToPlayer < 25 && !isHiding && teammate.userData.cakeState !== 'search') {
                teammate.userData.cakeState = 'chase';
                // Move toward player - can phase through walls if player spotted!
                const direction = new THREE.Vector3().subVectors(playerPos2D, teammatePos).normalize();
                const newPos = new THREE.Vector3(
                  teammate.position.x + direction.x * teammate.userData.cakeSpeed,
                  0,
                  teammate.position.z + direction.z * teammate.userData.cakeSpeed
                );
                
                // Normal collision check
                if (!checkCollision(newPos)) {
                  teammate.position.x = newPos.x;
                  teammate.position.z = newPos.z;
                }
                teammate.rotation.y = Math.atan2(direction.x, direction.z);
                
                // Catch player if close enough!
                if (distanceToPlayer < 3 && !isHiding) {
                  if (window.playerRole !== 'explorer') {
                    showGameOver('üíÄ GAME OVER', 'You were caught by ' + teammate.userData.name + '!', false);
                    return;
                  } else {
                    console.log('üõ°Ô∏è Debug mode: Prevented death from ' + teammate.userData.name);
                    // Push player away in debug mode
                    const escapeDirection = new THREE.Vector3().subVectors(playerPos2D, teammatePos).normalize();
                    const escapeDistance = 10;
                    camera.position.x = teammatePos.x + escapeDirection.x * escapeDistance;
                    camera.position.z = teammatePos.z + escapeDirection.z * escapeDistance;
                  }
                }
              } else if (teammate.userData.cakeState === 'patrol' || (distanceToPlayer > 30 && teammate.userData.cakeState === 'chase')) {
                // Return to patrol if player far away
                if (teammate.userData.cakeState === 'chase' && distanceToPlayer > 30) {
                  teammate.userData.cakeState = 'patrol';
                  console.log(teammate.userData.name + ' lost player, returning to patrol');
                }
                
                // Patrol waypoints when player is far
                const targetWaypoint = seekerWaypoints[teammate.userData.cakeWaypoint];
                const direction = new THREE.Vector3().subVectors(targetWaypoint, teammatePos).normalize();
                const newPos = new THREE.Vector3(
                  teammate.position.x + direction.x * teammate.userData.cakeSpeed,
                  0,
                  teammate.position.z + direction.z * teammate.userData.cakeSpeed
                );
                
                // Check collision before moving
                if (!checkCollision(newPos)) {
                  teammate.position.x = newPos.x;
                  teammate.position.z = newPos.z;
                } else {
                  // Skip to next waypoint if stuck
                  teammate.userData.cakeWaypoint = (teammate.userData.cakeWaypoint + 1) % seekerWaypoints.length;
                }
                teammate.rotation.y = Math.atan2(direction.x, direction.z);
                
                // Check if reached waypoint
                if (teammatePos.distanceTo(targetWaypoint) < 3) {
                  teammate.userData.cakeWaypoint = (teammate.userData.cakeWaypoint + 1) % seekerWaypoints.length;
                }
              }
              
              return; // Skip normal teammate logic
            }
          });
          
          // Only hide from seeker after hiding phase
          if (!hidingPhase && seeker.visible) {
            teammates.forEach((teammate, index) => {
              // Skip if teammate is already caught
              if (teammate.userData.isCaught) return;
              
              if (!teammate.userData.isHiding) {
                // Check if seeker is nearby
                const teammatePos = new THREE.Vector3(teammate.position.x, 0, teammate.position.z);
                const distanceToSeeker = teammatePos.distanceTo(seekerPos2D);
                
                // Seeker catches teammate if too close!
                if (distanceToSeeker < 3) {  // Increased catch range
                  teammate.userData.isCaught = true;
                  teammate.userData.isCake = true; // Becomes a cake!
                  console.log('üíÄ ' + teammate.userData.name + ' was caught and became a cake!');
                  
                  // Visual feedback
                  const noiseIndicator = document.getElementById('noise-indicator');
                  noiseIndicator.style.display = 'block';
                  noiseIndicator.textContent = 'üéÇ ' + teammate.userData.name + ' became a cake!';
                  noiseIndicator.style.color = '#ff6600';
                  setTimeout(() => {
                    noiseIndicator.style.display = 'none';
                  }, 3000);
                  
                  // Transform teammate into cake visually
                  // Change color to pink (cake color)
                  teammate.children.forEach(child => {
                    if (child.material) {
                      child.material.color.setHex(0xff69b4); // Pink like cake
                      child.material.emissive.setHex(0xff1493);
                      child.material.emissiveIntensity = 0.3;
                    }
                  });
                  
                  // Initialize cake AI for this teammate
                  teammate.userData.cakeWaypoint = Math.floor(Math.random() * seekerWaypoints.length);
                  teammate.userData.cakeSpeed = 0.03;
                  
                  // Check if all teammates are caught
                  const caughtCount = teammates.filter(tm => tm.userData.isCaught).length;
                  console.log('Teammates caught: ' + caughtCount + '/' + teammates.length);
                  console.log('Total cakes hunting: ' + (caughtCount + 1)); // +1 for original cake
                  
                  return; // Skip rest of logic for this teammate
                }
                
                // If seeker is close, find nearest hiding spot
                if (distanceToSeeker < 20) {
                let nearestSpot = null;
                let nearestDist = Infinity;
                
                for (let spot of hidingSpots) {
                  if (!spot.userData.occupied) {
                    const spotPos = new THREE.Vector3(spot.position.x, 0, spot.position.z);
                    const dist = teammatePos.distanceTo(spotPos);
                    if (dist < nearestDist) {
                      nearestDist = dist;
                      nearestSpot = spot;
                    }
                  }
                }
                
                if (nearestSpot && nearestDist < 2) {
                  // Hide in spot
                  teammate.userData.isHiding = true;
                  teammate.userData.hidingSpot = nearestSpot;
                  nearestSpot.userData.occupied = true;
                  teammate.position.set(nearestSpot.position.x, 0, nearestSpot.position.z);
                  // Keep visible so player can see where they're hiding
                  console.log(teammate.userData.name + ' is hiding in ' + nearestSpot.userData.type);
                } else if (nearestSpot) {
                  // Move towards hiding spot
                  const direction = new THREE.Vector3().subVectors(
                    new THREE.Vector3(nearestSpot.position.x, 0, nearestSpot.position.z),
                    teammatePos
                  ).normalize();
                  teammate.position.x += direction.x * 0.03;
                  teammate.position.z += direction.z * 0.03;
                }
              }
            } else {
              // Already hiding, check if safe to leave
              const distanceToSeeker = new THREE.Vector3(teammate.position.x, 0, teammate.position.z).distanceTo(seekerPos2D);
              if (distanceToSeeker > 25) {
                // Safe to leave - move to random nearby position
                teammate.userData.isHiding = false;
                if (teammate.userData.hidingSpot) {
                  teammate.userData.hidingSpot.userData.occupied = false;
                  teammate.userData.hidingSpot = null;
                }
                // Move to random position away from hiding spot
                const randomAngle = Math.random() * Math.PI * 2;
                teammate.position.x += Math.cos(randomAngle) * 5;
                teammate.position.z += Math.sin(randomAngle) * 5;
                console.log(teammate.userData.name + ' left hiding spot');
              }
            }
          });
          } // End of if (!hidingPhase && seeker.visible)
        }
        
        // === AI HIDER AUTO-HIDE BEHAVIOR (Seeker Mode) ===
        if (window.playerRole === 'seeker' && aiHider.visible) {
          if (!aiHider.userData.isHiding) {
            // Check if player is nearby
            const hiderPos = new THREE.Vector3(aiHider.position.x, 0, aiHider.position.z);
            const playerPos2D = new THREE.Vector3(camera.position.x, 0, camera.position.z);
            const distanceToPlayer = hiderPos.distanceTo(playerPos2D);
            
            // If player is close, find nearest hiding spot
            if (distanceToPlayer < 20) {
              let nearestSpot = null;
              let nearestDist = Infinity;
              
              for (let spot of hidingSpots) {
                if (!spot.userData.occupied) {
                  const spotPos = new THREE.Vector3(spot.position.x, 0, spot.position.z);
                  const dist = hiderPos.distanceTo(spotPos);
                  if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestSpot = spot;
                  }
                }
              }
              
              if (nearestSpot && nearestDist < 2) {
                // Hide in spot
                aiHider.userData.isHiding = true;
                aiHider.userData.hidingSpot = nearestSpot;
                nearestSpot.userData.occupied = true;
                aiHider.position.set(nearestSpot.position.x, 0, nearestSpot.position.z);
                aiHider.visible = false; // Hide visually
              } else if (nearestSpot) {
                // Move towards hiding spot
                const direction = new THREE.Vector3().subVectors(
                  new THREE.Vector3(nearestSpot.position.x, 0, nearestSpot.position.z),
                  hiderPos
                ).normalize();
                aiHider.position.x += direction.x * 0.025;
                aiHider.position.z += direction.z * 0.025;
              }
            }
          } else {
            // Already hiding, check if player is far
            const distanceToPlayer = new THREE.Vector3(aiHider.position.x, 0, aiHider.position.z).distanceTo(
              new THREE.Vector3(camera.position.x, 0, camera.position.z)
            );
            if (distanceToPlayer > 25) {
              // Safe to leave
              aiHider.userData.isHiding = false;
              if (aiHider.userData.hidingSpot) {
                aiHider.userData.hidingSpot.userData.occupied = false;
                aiHider.userData.hidingSpot = null;
              }
              aiHider.visible = true;
            }
          }
        }
        
        // Show seeker after hiding phase
        if (!hidingPhase && !seeker.visible) {
          seeker.visible = true;
          seekerFlashlight.visible = true;
        }
        
        // === FLASHLIGHT BATTERY DRAIN (Unlimited in explorer mode) ===
        if (flashlightOn && flashlightBattery > 0 && window.playerRole !== 'explorer') {
          flashlightBattery -= 0.05;
          if (flashlightBattery <= 0) {
            flashlightBattery = 0;
            flashlightOn = false;
            flashlight.visible = false;
          }
        } else if (window.playerRole === 'explorer') {
          // Unlimited battery in explorer mode
          flashlightBattery = 100;
        }
        
        // === UPDATE UI ===
        const timerEl = document.getElementById('timer');
        const batteryEl = document.getElementById('flashlight-battery');
        const roleEl = document.getElementById('role');
        const foundEl = document.getElementById('found');
        
        // Update hiding phase timer (for hiders and explorer/debug mode)
        if (hidingPhase && (window.playerRole === 'hider' || window.playerRole === 'explorer')) {
          hideTime -= 0.016;
          const hideTimerEl = document.getElementById('hide-timer');
          if (hideTimerEl) {
            hideTimerEl.textContent = Math.floor(hideTime);
          } else {
            console.error('hide-timer element not found!');
          }
          // Debug timer
          if (Math.floor(hideTime) % 10 === 0 && hideTime > 0) {
            console.log('Hiding phase time remaining:', Math.floor(hideTime));
          }
          
          if (hideTime <= 0) {
            hidingPhase = false;
            document.getElementById('hiding-phase').style.display = 'none';
          }
          // Don't update game time during hiding phase
        } else if (window.playerRole !== 'explorer') {
          // Normal game time (after hiding phase or if seeker, but not explorer)
          gameTime -= 0.016;
          if (gameTime <= 0) {
            if (window.playerRole === 'hider') {
              showGameOver('\ud83c\udf89 YOU WIN!', 'You survived 5 minutes! Congratulations!', true);
            } else {
              showGameOver('\ud83d\udc80 TIME UP!', 'You failed to catch the hider!', false);
            }
            return;
          }
        }
        if (window.playerRole === 'explorer') {
          timerEl.textContent = 'üõ°Ô∏è DEBUG MODE (Invincible)';
        } else {
          timerEl.textContent = '‚è±Ô∏è No Time Limit';
        }
        batteryEl.textContent = `üî¶ Battery: ${Math.floor(flashlightBattery)}%`;
        batteryEl.style.color = flashlightBattery < 20 ? '#ff3333' : '#ffdd00';
        
        // Update volume meter
        const volumeFill = document.getElementById('volume-fill');
        const volumeText = document.getElementById('volume-text');
        volumeFill.style.width = `${volumeLevel}%`;
        
        // Display player movement volume with threshold (bottom left)
        const threshold = Math.floor(detectionThreshold);
        const volume = Math.floor(volumeLevel);
        
        // Color changes based on proximity to threshold
        let volumeColor = '#00ff00'; // Green - safe
        if (volumeLevel >= detectionThreshold * 0.8) {
          volumeColor = '#ff3333'; // Red - danger!
        } else if (volumeLevel >= detectionThreshold * 0.6) {
          volumeColor = '#ffaa00'; // Orange - warning
        }
        
        if (volumeLevel === 0) {
          volumeText.textContent = `Silent: ${volume}% / ${threshold}%`;
          volumeText.style.color = '#ffffff';
        } else if (volumeLevel < 30) {
          volumeText.textContent = `Sneaking: ${volume}% / ${threshold}%`;
          volumeText.style.color = volumeColor;
        } else if (volumeLevel < 70) {
          volumeText.textContent = `Walking: ${volume}% / ${threshold}%`;
          volumeText.style.color = volumeColor;
        } else {
          volumeText.textContent = `SPRINTING: ${volume}% / ${threshold}% ‚ö†Ô∏è`;
          volumeText.style.color = volumeColor;
        }
        
        // NEW CAKE AUDIO LINE SYSTEM - Show all cakes with directional indicators
        if (!hidingPhase && (window.playerRole === 'hider' || window.playerRole === 'explorer') && seeker.visible) {
          const playerPos2D = new THREE.Vector3(camera.position.x, 0, camera.position.z);
          
          // Get player's facing direction for angle calculations
          const playerDirection = new THREE.Vector3();
          camera.getWorldDirection(playerDirection);
          const playerAngle = Math.atan2(playerDirection.x, playerDirection.z);
          
          // Calculate for original cake (Red)
          const originalCakePos = new THREE.Vector3(seeker.position.x, 0, seeker.position.z);
          const originalCakeDist = playerPos2D.distanceTo(originalCakePos);
          const originalCakeIndicator = document.getElementById('original-cake-indicator');
          const originalCakePercent = document.getElementById('original-cake-percent');
          
          if (originalCakeDist < 30) {
            const volume = Math.max(0, 100 - (originalCakeDist / 30) * 100);
            const direction = new THREE.Vector3().subVectors(originalCakePos, playerPos2D);
            const angleToTarget = Math.atan2(direction.x, direction.z);
            let relativeAngle = angleToTarget - playerAngle;
            
            // Normalize angle
            while (relativeAngle > Math.PI) relativeAngle -= Math.PI * 2;
            while (relativeAngle < -Math.PI) relativeAngle += Math.PI * 2;
            
            // Convert to position on line (-1 to 1, where 0 is center)
            const normalizedPos = relativeAngle / Math.PI; // -1 (left) to 1 (right)
            const leftPercent = 50 + (normalizedPos * 45); // 5% to 95%
            
            originalCakeIndicator.style.left = `${leftPercent}%`;
            originalCakeIndicator.style.display = 'block';
            originalCakePercent.textContent = `${Math.floor(volume)}%`;
            
            // Jumpscare removed
          } else {
            originalCakeIndicator.style.display = 'none';
          }
          
          // Calculate for cake teammates
          let cakeTeammateIndex = 0;
          teammates.forEach((teammate, index) => {
            if (teammate.userData.isCake) {
              cakeTeammateIndex++;
              const teammatePos = new THREE.Vector3(teammate.position.x, 0, teammate.position.z);
              const teammateDist = playerPos2D.distanceTo(teammatePos);
              
              let indicator, percentEl;
              if (cakeTeammateIndex === 1) {
                indicator = document.getElementById('teammate1-cake-indicator');
                percentEl = document.getElementById('teammate1-cake-percent');
              } else if (cakeTeammateIndex === 2) {
                indicator = document.getElementById('teammate2-cake-indicator');
                percentEl = document.getElementById('teammate2-cake-percent');
              }
              
              if (indicator && teammateDist < 30) {
                const volume = Math.max(0, 100 - (teammateDist / 30) * 100);
                const direction = new THREE.Vector3().subVectors(teammatePos, playerPos2D);
                const angleToTarget = Math.atan2(direction.x, direction.z);
                let relativeAngle = angleToTarget - playerAngle;
                
                // Normalize angle
                while (relativeAngle > Math.PI) relativeAngle -= Math.PI * 2;
                while (relativeAngle < -Math.PI) relativeAngle += Math.PI * 2;
                
                // Convert to position on line
                const normalizedPos = relativeAngle / Math.PI;
                const leftPercent = 50 + (normalizedPos * 45);
                
                indicator.style.left = `${leftPercent}%`;
                indicator.style.display = 'block';
                percentEl.textContent = `${Math.floor(volume)}%`;
              } else if (indicator) {
                indicator.style.display = 'none';
              }
            }
          });
          
          // Hide unused teammate indicators
          if (cakeTeammateIndex < 1) {
            document.getElementById('teammate1-cake-indicator').style.display = 'none';
          }
          if (cakeTeammateIndex < 2) {
            document.getElementById('teammate2-cake-indicator').style.display = 'none';
          }
        } else {
          // Hide all indicators when not in hider mode
          document.getElementById('original-cake-indicator').style.display = 'none';
          document.getElementById('teammate1-cake-indicator').style.display = 'none';
          document.getElementById('teammate2-cake-indicator').style.display = 'none';
        }
        
        // Ambient jumpscares removed
        
        // Update camera card timer
        if (cameraCardActive) {
          cameraCardTimer -= 0.016;
          if (cameraCardTimer <= 0) {
            cameraCardActive = false;
            console.log('üì∑ Camera Card expired');
          }
        }
        
        if (window.playerRole === 'hider' || window.playerRole === 'explorer') {
          if (isHiding && currentLocker) {
            // Track hiding time (30 second limit)
            hideTimer += 0.016;
            if (hideTimer >= MAX_HIDE_TIME) {
              // Force exit after 30 seconds
              console.log('30 second limit reached! Forced out of hiding spot.');
              currentLocker.userData.occupied = false;
              
              // Move player away from hiding spot
              const spotPos = currentLocker.position;
              const exitOffset = 3;
              const directions = [
                {x: exitOffset, z: 0},
                {x: -exitOffset, z: 0},
                {x: 0, z: exitOffset},
                {x: 0, z: -exitOffset}
              ];
              
              for (let dir of directions) {
                const testPos = new THREE.Vector3(
                  spotPos.x + dir.x,
                  originalCameraY,
                  spotPos.z + dir.z
                );
                if (!checkCollision(testPos)) {
                  camera.position.copy(testPos);
                  break;
                }
              }
              
              currentLocker = null;
              isHiding = false;
              hideTimer = 0;
            }
            
            const spotType = currentLocker.userData.type || 'spot';
            const timeLeft = Math.floor(MAX_HIDE_TIME - hideTimer);
            roleEl.textContent = `Hiding in ${spotType.charAt(0).toUpperCase() + spotType.slice(1)} (${timeLeft}s)`;
            roleEl.style.color = timeLeft < 10 ? '#ff9900' : '#00ff00';
          } else if (isSpotted) {
            roleEl.textContent = 'SPOTTED!';
            roleEl.style.color = '#ff0000';
          } else if (distanceToPlayer < 10 && !isHiding) {
            roleEl.textContent = 'Seeker Nearby!';
            roleEl.style.color = '#ff9900';
          } else {
            roleEl.textContent = 'Hider';
            roleEl.style.color = '#00ff00';
          }
        } else if (window.playerRole === 'seeker') {
          // Seeker mode
          roleEl.textContent = 'Evil Cake üéÇ';
          roleEl.style.color = '#ff69b4';
        } else if (window.playerRole === 'explorer') {
          // Explorer mode
          if (isHiding && currentLocker) {
            const spotType = currentLocker.userData.type || 'spot';
            roleEl.textContent = `Testing ${spotType.charAt(0).toUpperCase() + spotType.slice(1)}`;
            roleEl.style.color = '#38ef7d';
          } else {
            roleEl.textContent = 'Explorer üåü';
            roleEl.style.color = '#38ef7d';
          }
        }
        
        // Update candles found
        const candlesEl = document.getElementById('candles');
        candlesEl.textContent = `${candlesFound}/${totalCandles}`;
        
        // Update tools UI
        const cameraCardUI = document.getElementById('camera-card-ui');
        const shieldUI = document.getElementById('shield-ui');
        
        if (cameraCardActive) {
          cameraCardUI.textContent = `üì∑ Camera Active: ${Math.ceil(cameraCardTimer)}s (${cameraCardCount} left)`;
          cameraCardUI.style.display = 'block';
          cameraCardUI.style.color = '#2196F3';
        } else if (cameraCardCount > 0) {
          cameraCardUI.textContent = `üì∑ Camera Card: Press [C] (${cameraCardCount})`;
          cameraCardUI.style.display = 'block';
          cameraCardUI.style.color = '#ffffff';
        } else {
          cameraCardUI.style.display = 'none';
        }
        
        if (hasSpellBook) {
          shieldUI.style.display = 'block';
          shieldUI.textContent = 'üìö Spell Book [V]';
          shieldUI.style.color = '#9C27B0';
        } else {
          shieldUI.style.display = 'none';
        }

        // === MINIMAP DRAWING ===
        if (window.playerRole === 'hider' || window.playerRole === 'explorer') {
          const canvas = document.getElementById('minimap-canvas');
          const ctx = canvas.getContext('2d');
          
          // Clear canvas
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(0, 0, 200, 200);
          
          // Draw house bounds (outer walls)
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 3;
          ctx.strokeRect(10, 10, 180, 180);
          
          // Draw 10-room layout on minimap
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 2;
          
          // Scale for rooms (house is 100x80)
          const scaleX = 180 / 100;
          const scaleZ = 180 / 80;
          const offsetX = 100;
          const offsetZ = 100;
          
          // === MAIN VERTICAL DIVIDERS (3 columns) ===
          // Left column divider (x = -25)
          const leftColX = offsetX + (-25 * scaleX);
          ctx.beginPath();
          ctx.moveTo(leftColX, 10);
          ctx.lineTo(leftColX, 190);
          ctx.stroke();
          
          // Right column divider (x = 25)
          const rightColX = offsetX + (25 * scaleX);
          ctx.beginPath();
          ctx.moveTo(rightColX, 10);
          ctx.lineTo(rightColX, 190);
          ctx.stroke();
          
          // === LEFT WING HORIZONTAL DIVIDERS ===
          // Room 1-2 divider (z = -13)
          const leftTop = offsetZ + (-13 * scaleZ);
          ctx.beginPath();
          ctx.moveTo(10, leftTop);
          ctx.lineTo(leftColX, leftTop);
          ctx.stroke();
          
          // Room 2-3 divider (z = 13)
          const leftBottom = offsetZ + (13 * scaleZ);
          ctx.beginPath();
          ctx.moveTo(10, leftBottom);
          ctx.lineTo(leftColX, leftBottom);
          ctx.stroke();
          
          // === CENTER SECTION HORIZONTAL DIVIDERS ===
          // Room 4-5 divider (z = -20)
          const centerTop = offsetZ + (-20 * scaleZ);
          ctx.beginPath();
          ctx.moveTo(leftColX, centerTop);
          ctx.lineTo(rightColX, centerTop);
          ctx.stroke();
          
          // Room 5-6 divider (z = 0)
          ctx.beginPath();
          ctx.moveTo(leftColX, offsetZ);
          ctx.lineTo(rightColX, offsetZ);
          ctx.stroke();
          
          // Room 6-7 divider (z = 20)
          const centerBottom = offsetZ + (20 * scaleZ);
          ctx.beginPath();
          ctx.moveTo(leftColX, centerBottom);
          ctx.lineTo(rightColX, centerBottom);
          ctx.stroke();
          
          // === RIGHT WING HORIZONTAL DIVIDERS ===
          // Room 8-9 divider (z = -13)
          ctx.beginPath();
          ctx.moveTo(rightColX, leftTop);
          ctx.lineTo(190, leftTop);
          ctx.stroke();
          
          // Room 9-10 divider (z = 13)
          ctx.beginPath();
          ctx.moveTo(rightColX, leftBottom);
          ctx.lineTo(190, leftBottom);
          ctx.stroke();
          
          // Draw altar marker in HALL (Room 7)
          const altarX = offsetX + (0 * scaleX);
          const altarZ = offsetZ + (27 * scaleZ);
          ctx.fillStyle = '#ffaa00';
          ctx.strokeStyle = '#ff6600';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(altarX, altarZ, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Altar label
          ctx.fillStyle = '#ffaa00';
          ctx.font = '8px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('ALTAR', altarX, altarZ - 8);
          
          // === ROOM LABELS ===
          ctx.font = '8px Arial';
          ctx.fillStyle = '#aaa';
          
          // Left wing rooms
          ctx.fillText('BED', offsetX + (-35 * scaleX), offsetZ + (-20 * scaleZ));
          ctx.fillText('BATH', offsetX + (-35 * scaleX), offsetZ + (0 * scaleZ));
          ctx.fillText('STUDY', offsetX + (-35 * scaleX), offsetZ + (20 * scaleZ));
          
          // Center rooms
          ctx.fillText('LIVING', offsetX + (0 * scaleX), offsetZ + (-27 * scaleZ));
          ctx.fillText('DINING', offsetX + (0 * scaleX), offsetZ + (-10 * scaleZ));
          ctx.fillText('KITCHEN', offsetX + (0 * scaleX), offsetZ + (10 * scaleZ));
          ctx.fillText('HALL', offsetX + (0 * scaleX), offsetZ + (27 * scaleZ));
          
          // Right wing rooms
          ctx.fillText('BED2', offsetX + (35 * scaleX), offsetZ + (-20 * scaleZ));
          ctx.fillText('OFFICE', offsetX + (35 * scaleX), offsetZ + (0 * scaleZ));
          ctx.fillText('LIBRARY', offsetX + (35 * scaleX), offsetZ + (20 * scaleZ));
          
          // Draw player (green dot with facing direction)
          const playerX = offsetX + (camera.position.x * scaleX);
          const playerZ = offsetZ + (camera.position.z * scaleZ);
          
          // Draw facing direction line
          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          const arrowLength = 8;
          const arrowEndX = playerX + direction.x * arrowLength;
          const arrowEndZ = playerZ + direction.z * arrowLength;
          
          // Draw direction line
          ctx.strokeStyle = '#0f0';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(playerX, playerZ);
          ctx.lineTo(arrowEndX, arrowEndZ);
          ctx.stroke();
          
          // Draw arrow head
          const angle = Math.atan2(direction.z, direction.x);
          const arrowSize = 4;
          ctx.fillStyle = '#0f0';
          ctx.beginPath();
          ctx.moveTo(arrowEndX, arrowEndZ);
          ctx.lineTo(
            arrowEndX - arrowSize * Math.cos(angle - Math.PI / 6),
            arrowEndZ - arrowSize * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            arrowEndX - arrowSize * Math.cos(angle + Math.PI / 6),
            arrowEndZ - arrowSize * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fill();
          
          // Draw player dot
          ctx.fillStyle = '#0f0';
          ctx.beginPath();
          ctx.arc(playerX, playerZ, 4, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw teammates (yellow dots for alive, pink for cakes)
          teammates.forEach(teammate => {
            const tmX = offsetX + (teammate.position.x * scaleX);
            const tmZ = offsetZ + (teammate.position.z * scaleZ);
            
            // If teammate became a cake, draw as pink/red (enemy)
            if (teammate.userData.isCake) {
              ctx.fillStyle = '#ff69b4'; // Pink - now a cake!
              ctx.strokeStyle = '#ff1493';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(tmX, tmZ, 4, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              
              // Pulsing effect for cakes
              ctx.strokeStyle = 'rgba(255, 105, 180, 0.5)';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(tmX, tmZ, 6 + Math.sin(Date.now() / 200) * 2, 0, Math.PI * 2);
              ctx.stroke();
            }
            // Different color if hiding
            else if (teammate.userData.isHiding) {
              ctx.fillStyle = '#fa0'; // Orange when hiding
              ctx.strokeStyle = '#ff0';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(tmX, tmZ, 4, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            } else {
              ctx.fillStyle = '#ff0'; // Yellow when moving
              ctx.beginPath();
              ctx.arc(tmX, tmZ, 3, 0, Math.PI * 2);
              ctx.fill();
            }
          });
          
          // Timed reveal system (every 10 seconds for 3 seconds)
          const currentTime = Date.now();
          if (!hidingPhase && (window.playerRole === 'hider' || window.playerRole === 'explorer') && seeker.visible) {
            if (currentTime - lastSeekerReveal > 10000) {
              seekerTimedReveal = true;
              lastSeekerReveal = currentTime;
              console.log('üî¥ Seeker revealed on minimap for 3 seconds!');
              setTimeout(() => {
                seekerTimedReveal = false;
                console.log('Seeker hidden from timed reveal');
              }, 3000);
            }
          }
          
          // Persistent seeker visibility when near player/teammates OR camera card active OR timed reveal
          seekerVisibleOnMap = false;
          if (!hidingPhase && (window.playerRole === 'hider' || window.playerRole === 'explorer') && seeker.visible) {
            // Timed reveal (every 10 seconds)
            if (seekerTimedReveal) {
              seekerVisibleOnMap = true;
            }
            // Camera Card makes seeker always visible
            else if (cameraCardActive) {
              seekerVisibleOnMap = true;
            }
            // Proximity-based visibility
            else {
              const seekerPos = new THREE.Vector3(seeker.position.x, 0, seeker.position.z);
              
              // Check if near player
              const playerPos2D = new THREE.Vector3(camera.position.x, 0, camera.position.z);
              if (seekerPos.distanceTo(playerPos2D) < 20) {
                seekerVisibleOnMap = true;
              }
              
              // Check if near any teammate
              for (let teammate of teammates) {
                const teammatePos = new THREE.Vector3(teammate.position.x, 0, teammate.position.z);
                if (seekerPos.distanceTo(teammatePos) < 20) {
                  seekerVisibleOnMap = true;
                  break;
                }
              }
            }
          }
          
          // Draw seeker (red dot) - persistent when near player or teammates
          if (seeker.visible && (window.playerRole === 'hider' || window.playerRole === 'explorer') && seekerVisibleOnMap) {
            const seekerX = offsetX + (seeker.position.x * scaleX);
            const seekerZ = offsetZ + (seeker.position.z * scaleZ);
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(seekerX, seekerZ, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Pulsing effect
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(seekerX, seekerZ, 6 + Math.sin(currentTime / 200) * 2, 0, Math.PI * 2);
            ctx.stroke();
          } else if (window.playerRole === 'explorer' && seeker.visible) {
            // Always show in explorer mode
            const seekerX = offsetX + (seeker.position.x * scaleX);
            const seekerZ = offsetZ + (seeker.position.z * scaleZ);
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(seekerX, seekerZ, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Animate point light for atmosphere (subtle in dark)
        const time = Date.now() * 0.001;
        pointLight.position.x = Math.sin(time) * 15;
        pointLight.position.z = Math.cos(time) * 15;
        pointLight.intensity = 0.4 + Math.sin(time * 10) * 0.1; // Dim flickering

        renderer.render(scene, camera);
      }

      // Don't start animation until game starts
      function startAnimationLoop() {
        animate();
      }
      
      // Set the actual start function now that everything is loaded
      startGameFunction = startGame;
      console.log('Game module fully loaded! startGameFunction is ready.');
      
      // Start rendering (but game logic waits for menu choice)
      animate();
      
      } catch(error) {
        console.error('FATAL ERROR loading game module:', error);
        alert('Failed to load game: ' + error.message + '\n\nCheck console for details.');
      }
    </script>
  </body>
</html>